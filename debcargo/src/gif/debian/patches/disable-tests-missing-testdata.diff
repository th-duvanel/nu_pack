Index: gif/Cargo.toml
===================================================================
--- gif.orig/Cargo.toml
+++ gif/Cargo.toml
@@ -22,18 +22,7 @@ readme = "README.md"
 license = "MIT/Apache-2.0"
 repository = "https://github.com/image-rs/image-gif"
 autobenches = false
-
-[[test]]
-name = "check_testimages"
-required-features = ["std"]
-
-[[test]]
-name = "crashtest"
-required-features = ["std"]
-
-[[test]]
-name = "decode"
-required-features = ["std"]
+autotests = false
 
 [[test]]
 name = "roundtrip"
Index: gif/src/reader/mod.rs
===================================================================
--- gif.orig/src/reader/mod.rs
+++ gif/src/reader/mod.rs
@@ -469,7 +469,7 @@ mod test {
 
     use super::{Decoder, InterlaceIterator};
     
-    #[test]
+    /*#[test]
     fn test_simple_indexed() {
         let mut decoder = Decoder::new(File::open("tests/samples/sample_1.gif").unwrap()).unwrap();
         let frame = decoder.read_next_frame().unwrap().unwrap();
@@ -485,7 +485,7 @@ mod test {
             2, 2, 2, 2, 2, 1, 1, 1, 1, 1,
             2, 2, 2, 2, 2, 1, 1, 1, 1, 1
         ][..])
-    }
+    }*/
 
     #[test]
     fn test_interlace_iterator() {
Index: gif/README.md
===================================================================
--- gif.orig/README.md
+++ gif/README.md
@@ -13,7 +13,7 @@ The high level interface consists of the
 
 ### Decoding GIF files
 
-```rust
+```no_run
 // Open the file
 use std::fs::File;
 let input = File::open("tests/samples/sample_1.gif").unwrap();
Index: gif/src/lib.rs
===================================================================
--- gif.orig/src/lib.rs
+++ gif/src/lib.rs
@@ -13,7 +13,7 @@
 //! 
 //! ### Decoding GIF files
 //! 
-//! ```rust
+//! ```no_run
 //! // Open the file
 //! use std::fs::File;
 //! let mut decoder = gif::DecodeOptions::new();
@@ -55,7 +55,7 @@
 //!     0, 0, 0, 1, 1, 0,
 //!     0, 0, 0, 0, 0, 0,
 //! ]];
-//! let mut image = File::create("tests/samples/beacon.gif").unwrap();;
+//! let mut image = File::create("target/beacon.gif").unwrap();;
 //! let mut encoder = Encoder::new(&mut image, width, height, color_map).unwrap();
 //! encoder.set_repeat(Repeat::Infinite).unwrap();
 //! for state in &beacon_states {
@@ -123,7 +123,7 @@ pub use crate::reader::{DecodeOptions, D
 
 pub use crate::encoder::{Encoder, ExtensionData, Repeat, EncodingError};
 
-#[cfg(test)]
+/*#[cfg(test)]
 #[test]
 fn round_trip() {
     use std::io::prelude::*;
@@ -139,7 +139,7 @@ fn round_trip() {
         encoder.write_frame(frame).unwrap();
     }
     assert_eq!(&data[..], &data2[..])
-}
+}*/
 
 macro_rules! insert_as_doc {
     { $content:expr } => {
Index: gif/tests/roundtrip.rs
===================================================================
--- gif.orig/tests/roundtrip.rs
+++ gif/tests/roundtrip.rs
@@ -1,10 +1,10 @@
 use gif::{ColorOutput, Decoder, Encoder, Frame};
 
-#[test]
+/*#[test]
 fn encode_roundtrip() {
     const ORIGINAL: &'static [u8] = include_bytes!(concat!(env!("CARGO_MANIFEST_DIR"), "/tests/samples/2x2.gif"));
     round_trip_from_image(ORIGINAL);
-}
+}*/
 
 fn round_trip_from_image(original: &[u8]) {
     let (width, height, global_palette);
