diff --git a/examples/fallback.rs b/examples/fallback.rs
deleted file mode 100644
index 2be18d9..0000000
--- a/examples/fallback.rs
+++ /dev/null
@@ -1,64 +0,0 @@
-// font-kit/examples/fallback.rs
-//
-// Copyright © 2019 The Pathfinder Project Developers.
-//
-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
-// option. This file may not be copied, modified, or distributed
-// except according to those terms.
-
-extern crate clap;
-extern crate font_kit;
-
-use clap::{App, Arg, ArgMatches};
-
-use font_kit::loader::Loader;
-use font_kit::source::SystemSource;
-
-#[cfg(any(target_family = "windows", target_os = "macos"))]
-static SANS_SERIF_FONT_REGULAR_POSTSCRIPT_NAME: &'static str = "ArialMT";
-#[cfg(not(any(target_family = "windows", target_os = "macos")))]
-static SANS_SERIF_FONT_REGULAR_POSTSCRIPT_NAME: &'static str = "DejaVuSans";
-
-fn get_args() -> ArgMatches<'static> {
-    let postscript_name_arg = Arg::with_name("POSTSCRIPT-NAME")
-        .help("PostScript name of the font")
-        .default_value(SANS_SERIF_FONT_REGULAR_POSTSCRIPT_NAME)
-        .index(1);
-    let text_arg = Arg::with_name("TEXT")
-        .help("Text to query")
-        .default_value("A")
-        .index(2);
-    let locale_arg = Arg::with_name("LOCALE")
-        .help("Locale for fallback query")
-        .default_value("en-US")
-        .index(3);
-    App::new("fallback")
-        .version("0.1")
-        .arg(postscript_name_arg)
-        .arg(text_arg)
-        .arg(locale_arg)
-        .get_matches()
-}
-
-fn main() {
-    let matches = get_args();
-    let postscript_name = matches.value_of("POSTSCRIPT-NAME").unwrap();
-    let text = matches.value_of("TEXT").unwrap();
-    let locale = matches.value_of("LOCALE").unwrap();
-    let font = SystemSource::new()
-        .select_by_postscript_name(&postscript_name)
-        .expect("Font not found")
-        .load()
-        .unwrap();
-    println!("{}: text: {:?}", postscript_name, text);
-    let fallback_result = font.get_fallbacks(text, locale);
-    println!(
-        "fallback valid substring length: {}",
-        fallback_result.valid_len
-    );
-    for font in &fallback_result.fonts {
-        println!("font: {}", font.font.full_name());
-    }
-}
diff --git a/examples/list-fonts.rs b/examples/list-fonts.rs
deleted file mode 100644
index 656551a..0000000
--- a/examples/list-fonts.rs
+++ /dev/null
@@ -1,56 +0,0 @@
-// font-kit/examples/list-fonts.rs
-//
-// Copyright © 2018 The Pathfinder Project Developers.
-//
-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
-// option. This file may not be copied, modified, or distributed
-// except according to those terms.
-
-//! Lists all fonts on the system.
-
-extern crate font_kit;
-extern crate pbr;
-extern crate prettytable;
-
-use font_kit::source::SystemSource;
-use pbr::ProgressBar;
-use prettytable::{Attr, Cell, Row, Table};
-
-fn main() {
-    let mut table = Table::new();
-    table.set_format(*prettytable::format::consts::FORMAT_NO_BORDER_LINE_SEPARATOR);
-    table.set_titles(Row::new(vec![
-        Cell::new("PostScript Name").with_style(Attr::Bold),
-        Cell::new("Name").with_style(Attr::Bold),
-        Cell::new("Family").with_style(Attr::Bold),
-        Cell::new("Style").with_style(Attr::Bold),
-        Cell::new("Weight").with_style(Attr::Bold),
-        Cell::new("Stretch").with_style(Attr::Bold),
-    ]));
-
-    let source = SystemSource::new();
-    let fonts = source.all_fonts().unwrap();
-    let mut progress_bar = ProgressBar::new(fonts.len() as u64);
-    progress_bar.message("Loading fonts… ");
-
-    for font in fonts {
-        if let Ok(font) = font.load() {
-            let properties = font.properties();
-            table.add_row(Row::new(vec![
-                Cell::new(&font.postscript_name().unwrap_or_else(|| "".to_owned())),
-                Cell::new(&font.full_name()),
-                Cell::new(&font.family_name()),
-                Cell::new(&properties.style.to_string()),
-                Cell::new(&properties.weight.0.to_string()),
-                Cell::new(&properties.stretch.0.to_string()),
-            ]));
-        }
-
-        progress_bar.inc();
-    }
-
-    progress_bar.finish_print("");
-    table.printstd();
-}
diff --git a/examples/match-font.rs b/examples/match-font.rs
deleted file mode 100644
index c5e5819..0000000
--- a/examples/match-font.rs
+++ /dev/null
@@ -1,66 +0,0 @@
-// font-kit/examples/match-font.rs
-//
-// Copyright © 2020 The Pathfinder Project Developers.
-//
-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
-// option. This file may not be copied, modified, or distributed
-// except according to those terms.
-
-//! Looks up fonts by name.
-
-extern crate font_kit;
-
-use font_kit::family_name::FamilyName;
-use font_kit::handle::Handle;
-use font_kit::properties::Properties;
-use font_kit::source::SystemSource;
-use std::env;
-
-fn main() -> Result<(), Box<dyn std::error::Error>> {
-    let args: Vec<_> = env::args().collect();
-    if args.len() != 2 {
-        println!("Usage:\n\tmatch-font \"Times New Roman, Arial, serif\"");
-        std::process::exit(1);
-    }
-
-    let mut families = Vec::new();
-    for family in args[1].split(',') {
-        let family = family.replace('\'', "");
-        let family = family.trim();
-        families.push(match family {
-            "serif" => FamilyName::Serif,
-            "sans-serif" => FamilyName::SansSerif,
-            "monospace" => FamilyName::Monospace,
-            "cursive" => FamilyName::Cursive,
-            "fantasy" => FamilyName::Fantasy,
-            _ => FamilyName::Title(family.to_string()),
-        });
-    }
-
-    let properties = Properties::default();
-    let handle = SystemSource::new().select_best_match(&families, &properties)?;
-
-    if let Handle::Path {
-        ref path,
-        font_index,
-    } = handle
-    {
-        println!("Path: {}", path.display());
-        println!("Index: {}", font_index);
-    }
-
-    let font = handle.load()?;
-
-    println!("Family name: {}", font.family_name());
-    println!(
-        "PostScript name: {}",
-        font.postscript_name().unwrap_or("?".to_string())
-    );
-    println!("Style: {:?}", font.properties().style);
-    println!("Weight: {:?}", font.properties().weight);
-    println!("Stretch: {:?}", font.properties().stretch);
-
-    Ok(())
-}
diff --git a/examples/render-glyph.rs b/examples/render-glyph.rs
deleted file mode 100644
index d178ff1..0000000
--- a/examples/render-glyph.rs
+++ /dev/null
@@ -1,177 +0,0 @@
-// font-kit/examples/render-glyph.rs
-//
-// Copyright © 2018 The Pathfinder Project Developers.
-//
-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
-// option. This file may not be copied, modified, or distributed
-// except according to those terms.
-
-extern crate clap;
-extern crate colored;
-extern crate font_kit;
-extern crate pathfinder_geometry;
-
-use clap::{App, Arg, ArgGroup, ArgMatches};
-use colored::Colorize;
-use font_kit::canvas::{Canvas, Format, RasterizationOptions};
-use font_kit::hinting::HintingOptions;
-use font_kit::source::SystemSource;
-use pathfinder_geometry::transform2d::Transform2F;
-use std::fmt::Write;
-
-#[cfg(any(target_family = "windows", target_os = "macos"))]
-static SANS_SERIF_FONT_REGULAR_POSTSCRIPT_NAME: &'static str = "ArialMT";
-#[cfg(not(any(target_family = "windows", target_os = "macos")))]
-static SANS_SERIF_FONT_REGULAR_POSTSCRIPT_NAME: &'static str = "DejaVuSans";
-
-fn get_args() -> ArgMatches<'static> {
-    let postscript_name_arg = Arg::with_name("POSTSCRIPT-NAME")
-        .help("PostScript name of the font")
-        .default_value(SANS_SERIF_FONT_REGULAR_POSTSCRIPT_NAME)
-        .index(1);
-    let glyph_arg = Arg::with_name("GLYPH")
-        .help("Character to render")
-        .default_value("A")
-        .index(2);
-    let size_arg = Arg::with_name("SIZE")
-        .help("Font size in blocks")
-        .default_value("32")
-        .index(3);
-    let grayscale_arg = Arg::with_name("grayscale")
-        .long("grayscale")
-        .help("Use grayscale antialiasing (default)");
-    let bilevel_arg = Arg::with_name("bilevel")
-        .help("Use bilevel (black & white) rasterization")
-        .short("b")
-        .long("bilevel");
-    let subpixel_arg = Arg::with_name("subpixel")
-        .help("Use subpixel (LCD) rasterization")
-        .short("s")
-        .long("subpixel");
-    let hinting_arg = Arg::with_name("hinting")
-        .help("Select hinting type")
-        .short("H")
-        .long("hinting")
-        .takes_value(true)
-        .possible_value("none")
-        .possible_value("vertical")
-        .possible_value("full")
-        .value_names(&["TYPE"]);
-    let transform_arg = Arg::with_name("transform")
-        .help("Transform to apply to glyph when rendering")
-        .long("transform")
-        .number_of_values(4);
-    let rasterization_mode_group =
-        ArgGroup::with_name("rasterization-mode").args(&["grayscale", "bilevel", "subpixel"]);
-    App::new("render-glyph")
-        .version("0.1")
-        .author("The Pathfinder Project Developers")
-        .about("Simple example tool to render glyphs with `font-kit`")
-        .arg(postscript_name_arg)
-        .arg(glyph_arg)
-        .arg(size_arg)
-        .arg(grayscale_arg)
-        .arg(bilevel_arg)
-        .arg(subpixel_arg)
-        .group(rasterization_mode_group)
-        .arg(hinting_arg)
-        .arg(transform_arg)
-        .get_matches()
-}
-
-fn main() {
-    let matches = get_args();
-
-    let postscript_name = matches.value_of("POSTSCRIPT-NAME").unwrap();
-    let character = matches.value_of("GLYPH").unwrap().chars().next().unwrap();
-    let size: f32 = matches.value_of("SIZE").unwrap().parse().unwrap();
-
-    let (canvas_format, rasterization_options) = if matches.is_present("bilevel") {
-        (Format::A8, RasterizationOptions::Bilevel)
-    } else if matches.is_present("subpixel") {
-        (Format::Rgb24, RasterizationOptions::SubpixelAa)
-    } else {
-        (Format::A8, RasterizationOptions::GrayscaleAa)
-    };
-
-    let mut transform = Transform2F::default();
-    if let Some(values) = matches.values_of("transform") {
-        if let [Ok(a), Ok(b), Ok(c), Ok(d)] = values.map(|x| x.parse()).collect::<Vec<_>>()[..] {
-            transform = Transform2F::row_major(a, b, c, d, 0.0, 0.0)
-        }
-    }
-
-    let hinting_options = match matches.value_of("hinting") {
-        Some(value) if value == "vertical" => HintingOptions::Vertical(size),
-        Some(value) if value == "full" => HintingOptions::Full(size),
-        _ => HintingOptions::None,
-    };
-
-    let font = SystemSource::new()
-        .select_by_postscript_name(&postscript_name)
-        .unwrap()
-        .load()
-        .unwrap();
-    let glyph_id = font.glyph_for_char(character).unwrap();
-
-    let raster_rect = font
-        .raster_bounds(
-            glyph_id,
-            size,
-            transform,
-            hinting_options,
-            rasterization_options,
-        )
-        .unwrap();
-
-    let mut canvas = Canvas::new(raster_rect.size(), canvas_format);
-    font.rasterize_glyph(
-        &mut canvas,
-        glyph_id,
-        size,
-        Transform2F::from_translation(-raster_rect.origin().to_f32()) * transform,
-        hinting_options,
-        rasterization_options,
-    )
-    .unwrap();
-
-    println!("glyph {}:", glyph_id);
-    for y in 0..raster_rect.height() {
-        let mut line = String::new();
-        let (row_start, row_end) = (y as usize * canvas.stride, (y + 1) as usize * canvas.stride);
-        let row = &canvas.pixels[row_start..row_end];
-        for x in 0..raster_rect.width() {
-            match canvas.format {
-                Format::Rgba32 => unimplemented!(),
-                Format::Rgb24 => {
-                    write!(
-                        &mut line,
-                        "{}{}{}",
-                        shade(row[x as usize * 3 + 0]).to_string().red(),
-                        shade(row[x as usize * 3 + 1]).to_string().green(),
-                        shade(row[x as usize * 3 + 2]).to_string().blue()
-                    )
-                    .unwrap();
-                }
-                Format::A8 => {
-                    let shade = shade(row[x as usize]);
-                    line.push(shade);
-                    line.push(shade);
-                }
-            }
-        }
-        println!("{}", line);
-    }
-}
-
-fn shade(value: u8) -> char {
-    match value {
-        0 => ' ',
-        1..=84 => '░',
-        85..=169 => '▒',
-        170..=254 => '▓',
-        _ => '█',
-    }
-}
