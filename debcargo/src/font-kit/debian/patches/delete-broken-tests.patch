diff --git a/src/loaders/freetype.rs b/src/loaders/freetype.rs
index ae93a1d..885f73b 100644
--- a/src/loaders/freetype.rs
+++ b/src/loaders/freetype.rs
@@ -1220,16 +1220,3 @@ extern "C" {
     fn FT_Get_Sfnt_Name_Count(face: FT_Face) -> FT_UInt;
 }
 
-#[cfg(test)]
-mod test {
-    use crate::loaders::freetype::Font;
-
-    static PCF_FONT_PATH: &'static str = "resources/tests/times-roman-pcf/timR12.pcf";
-    static PCF_FONT_POSTSCRIPT_NAME: &'static str = "Times-Roman";
-
-    #[test]
-    fn get_pcf_postscript_name() {
-        let font = Font::from_path(PCF_FONT_PATH, 0).unwrap();
-        assert_eq!(font.postscript_name().unwrap(), PCF_FONT_POSTSCRIPT_NAME);
-    }
-}
diff --git a/tests/tests.rs b/tests/tests.rs
index 39d4b6b..2de6966 100644
--- a/tests/tests.rs
+++ b/tests/tests.rs
@@ -83,39 +83,6 @@ pub fn get_font_full_name_from_lowercase_family_name() {
     assert_eq!(font.full_name(), KNOWN_SYSTEM_FONT_NAME);
 }
 
-#[test]
-pub fn load_font_from_file() {
-    let mut file = File::open(TEST_FONT_FILE_PATH).unwrap();
-    let font = Font::from_file(&mut file, 0).unwrap();
-    assert_eq!(font.postscript_name().unwrap(), TEST_FONT_POSTSCRIPT_NAME);
-}
-
-#[test]
-pub fn load_font_from_memory() {
-    let mut file = File::open(TEST_FONT_FILE_PATH).unwrap();
-    let mut font_data = vec![];
-    file.read_to_end(&mut font_data).unwrap();
-    let font = Font::from_bytes(Arc::new(font_data), 0).unwrap();
-    assert_eq!(font.postscript_name().unwrap(), TEST_FONT_POSTSCRIPT_NAME);
-}
-
-#[test]
-pub fn analyze_file() {
-    let mut file = File::open(TEST_FONT_FILE_PATH).unwrap();
-    assert_eq!(Font::analyze_file(&mut file).unwrap(), FileType::Single);
-}
-
-#[test]
-pub fn analyze_bytes() {
-    let mut file = File::open(TEST_FONT_FILE_PATH).unwrap();
-    let mut font_data = vec![];
-    file.read_to_end(&mut font_data).unwrap();
-    assert_eq!(
-        Font::analyze_bytes(Arc::new(font_data)).unwrap(),
-        FileType::Single
-    );
-}
-
 #[cfg(feature = "source")]
 #[test]
 pub fn get_glyph_for_char() {
@@ -306,170 +273,6 @@ pub fn get_vertically_hinted_glyph_outline() {
     );
 }
 
-// Right now, only FreeType can do hinting.
-#[cfg(all(
-    not(any(target_os = "macos", target_os = "ios", target_family = "windows")),
-    feature = "loader-freetype-default",
-    feature = "source"
-))]
-#[test]
-pub fn get_fully_hinted_glyph_outline() {
-    let font = SystemSource::new()
-        .select_best_match(&[FamilyName::SansSerif], &Properties::new())
-        .unwrap()
-        .load()
-        .unwrap();
-    let glyph = font.glyph_for_char('i').expect("No glyph for char!");
-    let mut outline_builder = OutlineBuilder::new();
-    font.outline(glyph, HintingOptions::Full(10.0), &mut outline_builder)
-        .unwrap();
-
-    let outline = outline_builder.into_outline();
-    assert_eq!(
-        outline,
-        Outline {
-            contours: vec![
-                Contour {
-                    positions: vec![
-                        Vector2F::new(137.6, 1228.8),
-                        Vector2F::new(137.6, 1433.6),
-                        Vector2F::new(316.80002, 1433.6),
-                        Vector2F::new(316.80002, 1228.8),
-                    ],
-                    flags: vec![PointFlags::empty(); 4],
-                },
-                Contour {
-                    positions: vec![
-                        Vector2F::new(137.6, 0.0),
-                        Vector2F::new(137.6, 1024.0),
-                        Vector2F::new(316.80002, 1024.0),
-                        Vector2F::new(316.80002, 0.0),
-                    ],
-                    flags: vec![PointFlags::empty(); 4],
-                },
-            ],
-        }
-    );
-}
-
-#[cfg(all(
-    feature = "source",
-    not(any(target_os = "macos", target_os = "ios", target_family = "windows"))
-))]
-#[test]
-pub fn get_fully_hinted_glyph_outline() {
-    let mut file = File::open(FILE_PATH_INCONSOLATA_TTF).unwrap();
-    let font = Font::from_file(&mut file, 0).unwrap();
-    let glyph = font.glyph_for_char('i').expect("No glyph for char!");
-
-    let mut outline_builder = OutlineBuilder::new();
-    font.outline(glyph, HintingOptions::Full(10.0), &mut outline_builder)
-        .unwrap();
-
-    let outline = outline_builder.into_outline();
-    assert_eq!(
-        outline,
-        Outline {
-            contours: vec![
-                Contour {
-                    positions: vec![
-                        Vector2F::new(100.0, 100.0),
-                        Vector2F::new(200.0, 100.0),
-                        Vector2F::new(200.0, 400.0),
-                        Vector2F::new(100.0, 400.0),
-                        Vector2F::new(100.0, 500.0),
-                        Vector2F::new(300.0, 500.0),
-                        Vector2F::new(300.0, 100.0),
-                        Vector2F::new(400.0, 100.0),
-                        Vector2F::new(400.0, 0.0),
-                        Vector2F::new(100.0, 0.0),
-                    ],
-                    flags: vec![PointFlags::empty(); 10],
-                },
-                Contour {
-                    positions: vec![
-                        Vector2F::new(200.0, 600.0),
-                        Vector2F::new(200.0, 600.0),
-                        Vector2F::new(200.0, 600.0),
-                        Vector2F::new(200.0, 600.0),
-                        Vector2F::new(200.0, 600.0),
-                        Vector2F::new(200.0, 700.0),
-                        Vector2F::new(200.0, 700.0),
-                        Vector2F::new(200.0, 700.0),
-                        Vector2F::new(200.0, 700.0),
-                        Vector2F::new(300.0, 700.0),
-                        Vector2F::new(300.0, 700.0),
-                        Vector2F::new(300.0, 700.0),
-                        Vector2F::new(300.0, 600.0),
-                        Vector2F::new(300.0, 600.0),
-                        Vector2F::new(300.0, 600.0),
-                        Vector2F::new(300.0, 600.0),
-                        Vector2F::new(200.0, 600.0),
-                    ],
-                    flags: vec![
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                    ],
-                },
-            ],
-        }
-    );
-}
-
-#[test]
-pub fn get_empty_glyph_outline() {
-    let mut file = File::open(TEST_FONT_FILE_PATH).unwrap();
-    let font = Font::from_file(&mut file, 0).unwrap();
-    let glyph = font.glyph_for_char(' ').expect("No glyph for char!");
-    let mut outline_builder = OutlineBuilder::new();
-    font.outline(glyph, HintingOptions::None, &mut outline_builder)
-        .unwrap();
-
-    let outline = outline_builder.into_outline();
-    assert_eq!(outline, Outline::new());
-}
-
-// https://github.com/servo/font-kit/issues/141
-#[test]
-pub fn get_glyph_raster_bounds() {
-    let mut file = File::open(FILE_PATH_INCONSOLATA_TTF).unwrap();
-    let font = Font::from_file(&mut file, 0).unwrap();
-    let glyph = font.glyph_for_char('J').expect("No glyph for char!");
-    let transform = Transform2F::default();
-    let size = 32.0;
-    let hinting_options = HintingOptions::None;
-    let rasterization_options = RasterizationOptions::GrayscaleAa;
-    #[cfg(all(not(target_family = "windows")))]
-    let expected_rect = RectI::new(Vector2I::new(1, -20), Vector2I::new(14, 21));
-    #[cfg(target_family = "windows")]
-    let expected_rect = RectI::new(Vector2I::new(1, -20), Vector2I::new(14, 20));
-    assert_eq!(
-        font.raster_bounds(
-            glyph,
-            size,
-            transform,
-            hinting_options,
-            rasterization_options
-        ),
-        Ok(expected_rect)
-    );
-}
-
 #[cfg(all(
     feature = "source",
     any(target_family = "windows", target_os = "macos", target_os = "ios")
@@ -581,35 +384,6 @@ pub fn get_font_metrics() {
     assert_eq!(bounding_box.width(), 5457.0);
 }
 
-#[cfg(all(
-    feature = "source",
-    not(any(target_family = "windows", target_os = "macos", target_os = "ios"))
-))]
-#[test]
-pub fn get_font_metrics() {
-    let font = SystemSource::new()
-        .select_best_match(&[FamilyName::SansSerif], &Properties::new())
-        .unwrap()
-        .load()
-        .unwrap();
-    let metrics = font.metrics();
-    assert_eq!(metrics.units_per_em, 2048);
-    assert_eq!(metrics.ascent, 1901.0);
-    assert_eq!(metrics.descent, -483.0);
-    assert_eq!(metrics.line_gap, 0.0); // FIXME(pcwalton): Huh?!
-    assert_eq!(metrics.underline_position, -130.0);
-    assert_eq!(metrics.underline_thickness, 90.0);
-    assert_eq!(metrics.cap_height, 0.0); // FIXME(pcwalton): Huh?!
-    assert_eq!(metrics.x_height, 0.0); // FIXME(pcwalton): Huh?!
-    assert_eq!(
-        metrics.bounding_box,
-        RectF::new(
-            Vector2F::new(-2090.0, -948.0),
-            Vector2F::new(5763.0, 3472.0)
-        )
-    );
-}
-
 #[cfg(feature = "source")]
 #[test]
 pub fn get_font_properties() {
@@ -841,54 +615,6 @@ pub fn rasterize_glyph() {
     check_curly_shape(&canvas);
 }
 
-// Tests that an empty glyph can be successfully rasterized to a 0x0 canvas (issue #7).
-#[cfg(feature = "source")]
-#[test]
-pub fn rasterize_empty_glyph() {
-    let mut file = File::open(TEST_FONT_FILE_PATH).unwrap();
-    let font = Font::from_file(&mut file, 0).unwrap();
-    let glyph = font.glyph_for_char(' ').expect("No glyph for char!");
-    let mut canvas = Canvas::new(Vector2I::splat(16), Format::A8);
-    font.rasterize_glyph(
-        &mut canvas,
-        glyph,
-        16.0,
-        Transform2F::default(),
-        HintingOptions::None,
-        RasterizationOptions::GrayscaleAa,
-    )
-    .unwrap();
-}
-
-// Tests that an empty glyph can be successfully rasterized to a 0x0 canvas (issue #7).
-#[cfg(feature = "source")]
-#[test]
-pub fn rasterize_empty_glyph_on_empty_canvas() {
-    let mut file = File::open(TEST_FONT_FILE_PATH).unwrap();
-    let font = Font::from_file(&mut file, 0).unwrap();
-    let glyph = font.glyph_for_char(' ').expect("No glyph for char!");
-    let size = 32.0;
-    let raster_rect = font
-        .raster_bounds(
-            glyph,
-            size,
-            Transform2F::default(),
-            HintingOptions::None,
-            RasterizationOptions::GrayscaleAa,
-        )
-        .unwrap();
-    let mut canvas = Canvas::new(raster_rect.size(), Format::A8);
-    font.rasterize_glyph(
-        &mut canvas,
-        glyph,
-        size,
-        Transform2F::from_translation(-raster_rect.origin().to_f32()),
-        HintingOptions::None,
-        RasterizationOptions::GrayscaleAa,
-    )
-    .unwrap();
-}
-
 #[cfg(feature = "source")]
 #[test]
 pub fn font_transform() {
@@ -923,223 +649,6 @@ pub fn font_transform() {
     assert!((raster_rect2.origin_y() - ((raster_rect.origin_y() - 8) * 3 + 8)).abs() <= 3);
 }
 
-#[test]
-fn load_fonts_from_opentype_collection() {
-    let mut file = File::open(TEST_FONT_COLLECTION_FILE_PATH).unwrap();
-    {
-        let font = Font::from_file(&mut file, 0).unwrap();
-        assert_eq!(
-            font.postscript_name().unwrap(),
-            TEST_FONT_COLLECTION_POSTSCRIPT_NAME[0]
-        );
-    }
-    let font = Font::from_file(&mut file, 1).unwrap();
-    assert_eq!(
-        font.postscript_name().unwrap(),
-        TEST_FONT_COLLECTION_POSTSCRIPT_NAME[1]
-    );
-}
-
-#[test]
-fn get_glyph_count() {
-    let font = Font::from_path(TEST_FONT_FILE_PATH, 0).unwrap();
-    assert_eq!(font.glyph_count(), 3084);
-}
-
-// The initial off-curve point used to cause an assertion in the FreeType backend.
-#[test]
-fn get_glyph_outline_eb_garamond_exclam() {
-    let mut file = File::open(FILE_PATH_EB_GARAMOND_TTF).unwrap();
-    let font = Font::from_file(&mut file, 0).unwrap();
-    let glyph = font.glyph_for_char('!').expect("No glyph for char!");
-    let mut outline_builder = OutlineBuilder::new();
-    font.outline(glyph, HintingOptions::None, &mut outline_builder)
-        .unwrap();
-
-    // The TrueType spec doesn't specify the rounding method for midpoints, as far as I can tell.
-    // So we are lenient and accept either values rounded down (what Core Text provides if the
-    // first point is off-curve, it seems) or precise floating-point values (what our FreeType
-    // loader provides).
-    let mut outline = outline_builder.into_outline();
-    for contour in &mut outline.contours {
-        for position in &mut contour.positions {
-            *position = position.floor();
-        }
-    }
-
-    println!("{:#?}", outline);
-    assert_eq!(
-        outline,
-        Outline {
-            contours: vec![
-                Contour {
-                    positions: vec![
-                        Vector2F::new(114.0, 598.0),
-                        Vector2F::new(114.0, 619.0),
-                        Vector2F::new(127.0, 634.0),
-                        Vector2F::new(141.0, 649.0),
-                        Vector2F::new(161.0, 649.0),
-                        Vector2F::new(181.0, 649.0),
-                        Vector2F::new(193.0, 634.0),
-                        Vector2F::new(206.0, 619.0),
-                        Vector2F::new(206.0, 598.0),
-                        Vector2F::new(206.0, 526.0),
-                        Vector2F::new(176.0, 244.0),
-                        Vector2F::new(172.0, 205.0),
-                        Vector2F::new(158.0, 205.0),
-                        Vector2F::new(144.0, 205.0),
-                        Vector2F::new(140.0, 244.0),
-                        Vector2F::new(114.0, 491.0),
-                        Vector2F::new(114.0, 598.0),
-                    ],
-                    flags: vec![
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                    ],
-                },
-                Contour {
-                    positions: vec![
-                        Vector2F::new(117.0, 88.0),
-                        Vector2F::new(135.0, 106.0),
-                        Vector2F::new(160.0, 106.0),
-                        Vector2F::new(185.0, 106.0),
-                        Vector2F::new(202.0, 88.0),
-                        Vector2F::new(220.0, 71.0),
-                        Vector2F::new(220.0, 46.0),
-                        Vector2F::new(220.0, 21.0),
-                        Vector2F::new(202.0, 3.0),
-                        Vector2F::new(185.0, -14.0),
-                        Vector2F::new(160.0, -14.0),
-                        Vector2F::new(135.0, -14.0),
-                        Vector2F::new(117.0, 3.0),
-                        Vector2F::new(100.0, 21.0),
-                        Vector2F::new(100.0, 46.0),
-                        Vector2F::new(100.0, 71.0),
-                        Vector2F::new(117.0, 88.0),
-                    ],
-                    flags: vec![
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                        PointFlags::CONTROL_POINT_0,
-                        PointFlags::empty(),
-                    ],
-                },
-            ],
-        }
-    );
-}
-
-// https://github.com/pcwalton/pathfinder/issues/84
-#[allow(non_snake_case)]
-#[test]
-fn get_glyph_outline_inconsolata_J() {
-    let mut file = File::open(FILE_PATH_INCONSOLATA_TTF).unwrap();
-    let font = Font::from_file(&mut file, 0).unwrap();
-    let glyph = font.glyph_for_char('J').expect("No glyph for char!");
-    let mut outline_builder = OutlineBuilder::new();
-    font.outline(glyph, HintingOptions::None, &mut outline_builder)
-        .unwrap();
-
-    let outline = outline_builder.into_outline();
-    assert_eq!(
-        outline,
-        Outline {
-            contours: vec![Contour {
-                positions: vec![
-                    Vector2F::new(198.0, -11.0),
-                    Vector2F::new(106.0, -11.0),
-                    Vector2F::new(49.0, 58.0),
-                    Vector2F::new(89.0, 108.0),
-                    Vector2F::new(96.0, 116.0),
-                    Vector2F::new(101.0, 112.0),
-                    Vector2F::new(102.0, 102.0),
-                    Vector2F::new(106.0, 95.0),
-                    Vector2F::new(110.0, 88.0),
-                    Vector2F::new(122.0, 78.0),
-                    Vector2F::new(157.0, 51.0),
-                    Vector2F::new(196.0, 51.0),
-                    Vector2F::new(247.0, 51.0),
-                    Vector2F::new(269.5, 86.5),
-                    Vector2F::new(292.0, 122.0),
-                    Vector2F::new(292.0, 208.0),
-                    Vector2F::new(292.0, 564.0),
-                    Vector2F::new(172.0, 564.0),
-                    Vector2F::new(172.0, 623.0),
-                    Vector2F::new(457.0, 623.0),
-                    Vector2F::new(457.0, 564.0),
-                    Vector2F::new(361.0, 564.0),
-                    Vector2F::new(361.0, 209.0),
-                    Vector2F::new(363.0, 133.0),
-                    Vector2F::new(341.0, 84.0),
-                    Vector2F::new(319.0, 35.0),
-                    Vector2F::new(281.5, 12.0),
-                    Vector2F::new(244.0, -11.0),
-                    Vector2F::new(198.0, -11.0),
-                ],
-                flags: vec![
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                    PointFlags::CONTROL_POINT_0,
-                    PointFlags::empty(),
-                ],
-            }],
-        }
-    );
-}
-
 // Makes sure that a canvas has an "L" shape in it. This is used to test rasterization.
 #[allow(non_snake_case)]
 fn check_L_shape(canvas: &Canvas) {
