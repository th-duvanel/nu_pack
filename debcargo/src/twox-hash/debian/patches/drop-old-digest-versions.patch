diff --git a/Cargo.toml b/Cargo.toml
index 16aa1f4..25e8323 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -32,23 +32,11 @@ version = ">= 0.1, < 2"
 default-features = false
 
 [dependencies.digest]
-version = "0.8"
-optional = true
-default-features = false
-package = "digest"
-
-[dependencies.digest_0_10]
 version = "0.10"
 optional = true
 default-features = false
 package = "digest"
 
-[dependencies.digest_0_9]
-version = "0.9"
-optional = true
-default-features = false
-package = "digest"
-
 [dependencies.rand]
 version = ">= 0.3.10, < 0.9"
 optional = true
diff --git a/src/digest_0_10_support.rs b/src/digest_0_10_support.rs
deleted file mode 100644
index 935c096..0000000
--- a/src/digest_0_10_support.rs
+++ /dev/null
@@ -1,92 +0,0 @@
-use core::hash::Hasher;
-
-use digest_0_10::{
-    generic_array::typenum::consts::{U16, U4, U8},
-    FixedOutput, HashMarker, Output, OutputSizeUser, Update,
-};
-
-use crate::{xxh3, XxHash32, XxHash64};
-
-// ----------
-
-impl Update for XxHash32 {
-    fn update(&mut self, data: &[u8]) {
-        self.write(data);
-    }
-}
-
-impl OutputSizeUser for XxHash32 {
-    type OutputSize = U4;
-}
-
-impl FixedOutput for XxHash32 {
-    fn finalize_into(self, out: &mut Output<Self>) {
-        let tmp: &mut [u8; 4] = out.as_mut();
-        *tmp = self.finish().to_be_bytes();
-    }
-}
-
-impl HashMarker for XxHash32 {}
-
-// ----------
-
-impl Update for XxHash64 {
-    fn update(&mut self, data: &[u8]) {
-        self.write(data);
-    }
-}
-
-impl OutputSizeUser for XxHash64 {
-    type OutputSize = U8;
-}
-
-impl FixedOutput for XxHash64 {
-    fn finalize_into(self, out: &mut Output<Self>) {
-        let tmp: &mut [u8; 8] = out.as_mut();
-        *tmp = self.finish().to_be_bytes();
-    }
-}
-
-impl HashMarker for XxHash64 {}
-
-// ----------
-
-impl Update for xxh3::Hash64 {
-    fn update(&mut self, data: &[u8]) {
-        self.write(data);
-    }
-}
-
-impl OutputSizeUser for xxh3::Hash64 {
-    type OutputSize = U8;
-}
-
-impl FixedOutput for xxh3::Hash64 {
-    fn finalize_into(self, out: &mut Output<Self>) {
-        let tmp: &mut [u8; 8] = out.as_mut();
-        *tmp = self.finish().to_be_bytes();
-    }
-}
-
-impl HashMarker for xxh3::Hash64 {}
-
-// ----------
-
-impl Update for xxh3::Hash128 {
-    fn update(&mut self, data: &[u8]) {
-        self.write(data);
-    }
-}
-
-impl OutputSizeUser for xxh3::Hash128 {
-    type OutputSize = U16;
-}
-
-impl FixedOutput for xxh3::Hash128 {
-    fn finalize_into(self, out: &mut Output<Self>) {
-        let tmp: &mut [u8; 16] = out.as_mut();
-        *tmp = xxh3::HasherExt::finish_ext(&self).to_be_bytes();
-    }
-}
-
-impl HashMarker for xxh3::Hash128 {}
diff --git a/src/digest_0_9_support.rs b/src/digest_0_9_support.rs
deleted file mode 100644
index 67788cd..0000000
--- a/src/digest_0_9_support.rs
+++ /dev/null
@@ -1,179 +0,0 @@
-use core::hash::Hasher;
-
-use digest_0_9::{
-    generic_array::{
-        typenum::consts::{U16, U4, U8},
-        GenericArray,
-    },
-    Digest,
-};
-
-use crate::{xxh3, XxHash32, XxHash64};
-
-impl Digest for XxHash32 {
-    type OutputSize = U4;
-
-    fn new() -> Self {
-        Self::default()
-    }
-
-    fn update(&mut self, data: impl AsRef<[u8]>) {
-        self.write(data.as_ref());
-    }
-
-    fn chain(mut self, data: impl AsRef<[u8]>) -> Self
-    where
-        Self: Sized,
-    {
-        self.update(data);
-        self
-    }
-
-    fn finalize(self) -> GenericArray<u8, Self::OutputSize> {
-        self.finish().to_be_bytes().into()
-    }
-
-    fn finalize_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {
-        let result = self.finalize();
-        self.reset();
-        result
-    }
-
-    fn reset(&mut self) {
-        *self = Self::default();
-    }
-
-    fn output_size() -> usize {
-        4
-    }
-
-    fn digest(data: &[u8]) -> GenericArray<u8, Self::OutputSize> {
-        Self::new().chain(data).finalize()
-    }
-}
-
-impl Digest for XxHash64 {
-    type OutputSize = U8;
-
-    fn new() -> Self {
-        Self::default()
-    }
-
-    fn update(&mut self, data: impl AsRef<[u8]>) {
-        self.write(data.as_ref());
-    }
-
-    fn chain(mut self, data: impl AsRef<[u8]>) -> Self
-    where
-        Self: Sized,
-    {
-        self.update(data);
-        self
-    }
-
-    fn finalize(self) -> GenericArray<u8, Self::OutputSize> {
-        self.finish().to_be_bytes().into()
-    }
-
-    fn finalize_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {
-        let result = self.finalize();
-        self.reset();
-        result
-    }
-
-    fn reset(&mut self) {
-        *self = Self::default();
-    }
-
-    fn output_size() -> usize {
-        8
-    }
-
-    fn digest(data: &[u8]) -> GenericArray<u8, Self::OutputSize> {
-        Self::new().chain(data).finalize()
-    }
-}
-
-impl Digest for xxh3::Hash64 {
-    type OutputSize = U8;
-
-    fn new() -> Self {
-        Self::default()
-    }
-
-    fn update(&mut self, data: impl AsRef<[u8]>) {
-        self.write(data.as_ref());
-    }
-
-    fn chain(mut self, data: impl AsRef<[u8]>) -> Self
-    where
-        Self: Sized,
-    {
-        self.update(data);
-        self
-    }
-
-    fn finalize(self) -> GenericArray<u8, Self::OutputSize> {
-        self.finish().to_be_bytes().into()
-    }
-
-    fn finalize_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {
-        let result = self.clone().finalize();
-        self.reset();
-        result
-    }
-
-    fn reset(&mut self) {
-        *self = Self::default();
-    }
-
-    fn output_size() -> usize {
-        8
-    }
-
-    fn digest(data: &[u8]) -> GenericArray<u8, Self::OutputSize> {
-        Self::new().chain(data).finalize()
-    }
-}
-
-impl Digest for xxh3::Hash128 {
-    type OutputSize = U16;
-
-    fn new() -> Self {
-        Self::default()
-    }
-
-    fn update(&mut self, data: impl AsRef<[u8]>) {
-        self.write(data.as_ref());
-    }
-
-    fn chain(mut self, data: impl AsRef<[u8]>) -> Self
-    where
-        Self: Sized,
-    {
-        self.update(data);
-        self
-    }
-
-    fn finalize(self) -> GenericArray<u8, Self::OutputSize> {
-        xxh3::HasherExt::finish_ext(&self).to_be_bytes().into()
-    }
-
-    fn finalize_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {
-        let result = self.clone().finalize();
-        self.reset();
-        result
-    }
-
-    fn reset(&mut self) {
-        *self = Self::default();
-    }
-
-    fn output_size() -> usize {
-        8
-    }
-
-    fn digest(data: &[u8]) -> GenericArray<u8, Self::OutputSize> {
-        Self::new().chain(data).finalize()
-    }
-}
diff --git a/src/digest_support.rs b/src/digest_support.rs
index 7b00b9d..990116b 100644
--- a/src/digest_support.rs
+++ b/src/digest_support.rs
@@ -1,179 +1,92 @@
 use core::hash::Hasher;
 
 use digest::{
-    generic_array::{
-        typenum::consts::{U16, U4, U8},
-        GenericArray,
-    },
-    Digest,
+    generic_array::typenum::consts::{U16, U4, U8},
+    FixedOutput, HashMarker, Output, OutputSizeUser, Update,
 };
 
 use crate::{xxh3, XxHash32, XxHash64};
 
-impl Digest for XxHash32 {
-    type OutputSize = U4;
-
-    fn new() -> Self {
-        Self::default()
-    }
+// ----------
 
-    fn input<B: AsRef<[u8]>>(&mut self, data: B) {
-        self.write(data.as_ref());
-    }
-
-    fn chain<B: AsRef<[u8]>>(mut self, data: B) -> Self
-    where
-        Self: Sized,
-    {
-        self.input(data);
-        self
+impl Update for XxHash32 {
+    fn update(&mut self, data: &[u8]) {
+        self.write(data);
     }
+}
 
-    fn result(self) -> GenericArray<u8, Self::OutputSize> {
-        self.finish().to_be_bytes().into()
-    }
+impl OutputSizeUser for XxHash32 {
+    type OutputSize = U4;
+}
 
-    fn result_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {
-        let result = self.result();
-        self.reset();
-        result
+impl FixedOutput for XxHash32 {
+    fn finalize_into(self, out: &mut Output<Self>) {
+        let tmp: &mut [u8; 4] = out.as_mut();
+        *tmp = self.finish().to_be_bytes();
     }
+}
 
-    fn reset(&mut self) {
-        *self = Self::default();
-    }
+impl HashMarker for XxHash32 {}
 
-    fn output_size() -> usize {
-        4
-    }
+// ----------
 
-    fn digest(data: &[u8]) -> GenericArray<u8, Self::OutputSize> {
-        Self::new().chain(data).result()
+impl Update for XxHash64 {
+    fn update(&mut self, data: &[u8]) {
+        self.write(data);
     }
 }
 
-impl Digest for XxHash64 {
+impl OutputSizeUser for XxHash64 {
     type OutputSize = U8;
+}
 
-    fn new() -> Self {
-        Self::default()
-    }
-
-    fn input<B: AsRef<[u8]>>(&mut self, data: B) {
-        self.write(data.as_ref());
-    }
-
-    fn chain<B: AsRef<[u8]>>(mut self, data: B) -> Self
-    where
-        Self: Sized,
-    {
-        self.input(data);
-        self
-    }
-
-    fn result(self) -> GenericArray<u8, Self::OutputSize> {
-        self.finish().to_be_bytes().into()
-    }
-
-    fn result_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {
-        let result = self.result();
-        self.reset();
-        result
+impl FixedOutput for XxHash64 {
+    fn finalize_into(self, out: &mut Output<Self>) {
+        let tmp: &mut [u8; 8] = out.as_mut();
+        *tmp = self.finish().to_be_bytes();
     }
+}
 
-    fn reset(&mut self) {
-        *self = Self::default();
-    }
+impl HashMarker for XxHash64 {}
 
-    fn output_size() -> usize {
-        8
-    }
+// ----------
 
-    fn digest(data: &[u8]) -> GenericArray<u8, Self::OutputSize> {
-        Self::new().chain(data).result()
+impl Update for xxh3::Hash64 {
+    fn update(&mut self, data: &[u8]) {
+        self.write(data);
     }
 }
 
-impl Digest for xxh3::Hash64 {
+impl OutputSizeUser for xxh3::Hash64 {
     type OutputSize = U8;
+}
 
-    fn new() -> Self {
-        Self::default()
-    }
-
-    fn input<B: AsRef<[u8]>>(&mut self, data: B) {
-        self.write(data.as_ref());
-    }
-
-    fn chain<B: AsRef<[u8]>>(mut self, data: B) -> Self
-    where
-        Self: Sized,
-    {
-        self.input(data);
-        self
-    }
-
-    fn result(self) -> GenericArray<u8, Self::OutputSize> {
-        self.finish().to_be_bytes().into()
-    }
-
-    fn result_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {
-        let result = self.clone().result();
-        self.reset();
-        result
+impl FixedOutput for xxh3::Hash64 {
+    fn finalize_into(self, out: &mut Output<Self>) {
+        let tmp: &mut [u8; 8] = out.as_mut();
+        *tmp = self.finish().to_be_bytes();
     }
+}
 
-    fn reset(&mut self) {
-        *self = Self::default();
-    }
+impl HashMarker for xxh3::Hash64 {}
 
-    fn output_size() -> usize {
-        8
-    }
+// ----------
 
-    fn digest(data: &[u8]) -> GenericArray<u8, Self::OutputSize> {
-        Self::new().chain(data).result()
+impl Update for xxh3::Hash128 {
+    fn update(&mut self, data: &[u8]) {
+        self.write(data);
     }
 }
 
-impl Digest for xxh3::Hash128 {
+impl OutputSizeUser for xxh3::Hash128 {
     type OutputSize = U16;
+}
 
-    fn new() -> Self {
-        Self::default()
-    }
-
-    fn input<B: AsRef<[u8]>>(&mut self, data: B) {
-        self.write(data.as_ref());
-    }
-
-    fn chain<B: AsRef<[u8]>>(mut self, data: B) -> Self
-    where
-        Self: Sized,
-    {
-        self.input(data);
-        self
-    }
-
-    fn result(self) -> GenericArray<u8, Self::OutputSize> {
-        xxh3::HasherExt::finish_ext(&self).to_be_bytes().into()
-    }
-
-    fn result_reset(&mut self) -> GenericArray<u8, Self::OutputSize> {
-        let result = self.clone().result();
-        self.reset();
-        result
-    }
-
-    fn reset(&mut self) {
-        *self = Self::default();
-    }
-
-    fn output_size() -> usize {
-        8
-    }
-
-    fn digest(data: &[u8]) -> GenericArray<u8, Self::OutputSize> {
-        Self::new().chain(data).result()
+impl FixedOutput for xxh3::Hash128 {
+    fn finalize_into(self, out: &mut Output<Self>) {
+        let tmp: &mut [u8; 16] = out.as_mut();
+        *tmp = xxh3::HasherExt::finish_ext(&self).to_be_bytes();
     }
 }
+
+impl HashMarker for xxh3::Hash128 {}
diff --git a/src/lib.rs b/src/lib.rs
index 414dc8d..6ec2642 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -53,12 +53,6 @@ pub use std_support::xxh3::{
 #[cfg(feature = "digest")]
 mod digest_support;
 
-#[cfg(feature = "digest_0_9")]
-mod digest_0_9_support;
-
-#[cfg(feature = "digest_0_10")]
-mod digest_0_10_support;
-
 pub use crate::sixty_four::XxHash64;
 pub use crate::thirty_two::XxHash32;
 pub use crate::xxh3::{Hash128 as Xxh3Hash128, Hash64 as Xxh3Hash64};
