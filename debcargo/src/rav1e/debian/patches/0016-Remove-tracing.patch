--- a/Cargo.toml
+++ b/Cargo.toml
@@ -150,9 +150,6 @@
 [dependencies.paste]
 version = "1.0"
 
-[dependencies.profiling]
-version = "1"
-
 [dependencies.rayon]
 version = "1"
 
@@ -180,18 +177,6 @@
 version = "0.8"
 optional = true
 
-[dependencies.tracing]
-version = "0.1.40"
-optional = true
-
-[dependencies.tracing-chrome]
-version = "0.7.1"
-optional = true
-
-[dependencies.tracing-subscriber]
-version = "0.3.18"
-optional = true
-
 [dependencies.v_frame]
 version = "0.3.7"
 
@@ -269,12 +254,6 @@
 ]
 signal_support = ["signal-hook"]
 threading = []
-tracing = [
-    "profiling/profile-with-tracing",
-    "tracing-subscriber",
-    "tracing-chrome",
-    "dep:tracing",
-]
 
 [target."cfg(any(decode_test, decode_test_dav1d))".dependencies.system-deps]
 version = "6"
--- rust-rav1e-0.7.1.orig/src/activity.rs
+++ rust-rav1e-0.7.1/src/activity.rs
@@ -19,7 +19,6 @@ pub struct ActivityMask {
 }
 
 impl ActivityMask {
-  #[profiling::function]
   pub fn from_plane<T: Pixel>(luma_plane: &Plane<T>) -> ActivityMask {
     let PlaneConfig { width, height, .. } = luma_plane.cfg;
 
@@ -54,7 +53,6 @@ impl ActivityMask {
     ActivityMask { variances: variances.into_boxed_slice() }
   }
 
-  #[profiling::function]
   pub fn fill_scales(
     &self, bit_depth: usize, activity_scales: &mut Box<[DistortionScale]>,
   ) {
--- rust-rav1e-0.7.1.orig/src/api/internal.rs
+++ rust-rav1e-0.7.1/src/api/internal.rs
@@ -315,7 +315,6 @@ impl<T: Pixel> ContextInner<T> {
     }
   }
 
-  #[profiling::function]
   pub fn send_frame(
     &mut self, mut frame: Option<Arc<Frame<T>>>,
     params: Option<FrameParameters>,
@@ -647,7 +646,6 @@ impl<T: Pixel> ContextInner<T> {
   /// `rec_buffer` and `lookahead_rec_buffer` on the `FrameInvariants`. This
   /// function must be called after every new `FrameInvariants` is initially
   /// computed.
-  #[profiling::function]
   fn compute_lookahead_motion_vectors(&mut self, output_frameno: u64) {
     let frame_data = self.frame_data.get(&output_frameno).unwrap();
 
@@ -860,7 +858,6 @@ impl<T: Pixel> ContextInner<T> {
       });
   }
 
-  #[profiling::function]
   pub fn compute_keyframe_placement(
     lookahead_frames: &[&Arc<Frame<T>>], keyframes_forced: &BTreeSet<u64>,
     keyframe_detector: &mut SceneChangeDetector<T>,
@@ -879,7 +876,6 @@ impl<T: Pixel> ContextInner<T> {
     *next_lookahead_frame += 1;
   }
 
-  #[profiling::function]
   pub fn compute_frame_invariants(&mut self) {
     while self.set_frame_properties(self.next_lookahead_output_frameno).is_ok()
     {
@@ -892,7 +888,6 @@ impl<T: Pixel> ContextInner<T> {
     }
   }
 
-  #[profiling::function]
   fn update_block_importances(
     fi: &FrameInvariants<T>, me_stats: &crate::me::FrameMEStats,
     frame: &Frame<T>, reference_frame: &Frame<T>, bit_depth: usize,
@@ -1055,7 +1050,6 @@ impl<T: Pixel> ContextInner<T> {
   }
 
   /// Computes the block importances for the current output frame.
-  #[profiling::function]
   fn compute_block_importances(&mut self) {
     // SEF don't need block importances.
     if self.frame_data[&self.output_frameno]
@@ -1279,7 +1273,6 @@ impl<T: Pixel> ContextInner<T> {
     }
   }
 
-  #[profiling::function]
   pub fn encode_show_existing_packet(
     &mut self, cur_output_frameno: u64,
   ) -> Result<Packet<T>, EncoderStatus> {
@@ -1315,7 +1308,6 @@ impl<T: Pixel> ContextInner<T> {
     self.finalize_packet(rec, source, input_frameno, frame_type, qp, enc_stats)
   }
 
-  #[profiling::function]
   pub fn encode_normal_packet(
     &mut self, cur_output_frameno: u64,
   ) -> Result<Packet<T>, EncoderStatus> {
@@ -1478,7 +1470,6 @@ impl<T: Pixel> ContextInner<T> {
     }
   }
 
-  #[profiling::function]
   pub fn receive_packet(&mut self) -> Result<Packet<T>, EncoderStatus> {
     if self.done_processing() {
       return Err(EncoderStatus::LimitReached);
@@ -1544,7 +1535,6 @@ impl<T: Pixel> ContextInner<T> {
     })
   }
 
-  #[profiling::function]
   fn garbage_collect(&mut self, cur_input_frameno: u64) {
     if cur_input_frameno == 0 {
       return;
--- rust-rav1e-0.7.1.orig/src/api/lookahead.rs
+++ rust-rav1e-0.7.1/src/api/lookahead.rs
@@ -26,7 +26,6 @@ pub(crate) const IMP_BLOCK_SIZE_IN_MV_UN
 pub(crate) const IMP_BLOCK_AREA_IN_MV_UNITS: i64 =
   IMP_BLOCK_SIZE_IN_MV_UNITS * IMP_BLOCK_SIZE_IN_MV_UNITS;
 
-#[profiling::function]
 pub(crate) fn estimate_intra_costs<T: Pixel>(
   temp_plane: &mut Plane<T>, frame: &Frame<T>, bit_depth: usize,
   cpu_feature_level: CpuFeatureLevel,
@@ -122,7 +121,6 @@ pub(crate) fn estimate_intra_costs<T: Pi
   intra_costs.into_boxed_slice()
 }
 
-#[profiling::function]
 pub(crate) fn estimate_importance_block_difference<T: Pixel>(
   frame: Arc<Frame<T>>, ref_frame: Arc<Frame<T>>,
 ) -> f64 {
@@ -178,7 +176,6 @@ pub(crate) fn estimate_importance_block_
   imp_block_costs as f64 / (w_in_imp_b * h_in_imp_b) as f64
 }
 
-#[profiling::function]
 pub(crate) fn estimate_inter_costs<T: Pixel>(
   frame: Arc<Frame<T>>, ref_frame: Arc<Frame<T>>, bit_depth: usize,
   mut config: EncoderConfig, sequence: Arc<Sequence>, buffer: RefMEStats,
@@ -267,7 +264,6 @@ pub(crate) fn estimate_inter_costs<T: Pi
   inter_costs as f64 / (w_in_imp_b * h_in_imp_b) as f64
 }
 
-#[profiling::function]
 pub(crate) fn compute_motion_vectors<T: Pixel>(
   fi: &mut FrameInvariants<T>, fs: &mut FrameState<T>, inter_cfg: &InterConfig,
 ) {
--- rust-rav1e-0.7.1.orig/src/bin/muxer/ivf.rs
+++ rust-rav1e-0.7.1/src/bin/muxer/ivf.rs
@@ -36,7 +36,6 @@ impl Muxer for IvfMuxer {
     );
   }
 
-  #[profiling::function]
   fn write_frame(&mut self, pts: u64, data: &[u8], _frame_type: FrameType) {
     write_ivf_frame(&mut self.output, pts, data);
   }
--- rust-rav1e-0.7.1.orig/src/bin/muxer/y4m.rs
+++ rust-rav1e-0.7.1/src/bin/muxer/y4m.rs
@@ -12,7 +12,6 @@ use rav1e::prelude::*;
 use std::io::Write;
 use std::slice;
 
-#[profiling::function]
 pub fn write_y4m_frame<T: Pixel>(
   y4m_enc: &mut y4m::Encoder<Box<dyn Write + Send>>, rec: &Frame<T>,
   y4m_details: VideoDetails,
--- rust-rav1e-0.7.1.orig/src/bin/rav1e.rs
+++ rust-rav1e-0.7.1/src/bin/rav1e.rs
@@ -147,7 +147,6 @@ impl<D: Decoder> Source<D> {
     }
   }
 
-  #[profiling::function]
   fn read_frame<T: Pixel>(
     &mut self, ctx: &mut Context<T>, video_info: VideoDetails,
   ) -> Result<(), CliError> {
@@ -183,7 +182,6 @@ impl<D: Decoder> Source<D> {
 
 // Encode and write a frame.
 // Returns frame information in a `Result`.
-#[profiling::function]
 fn process_frame<T: Pixel, D: Decoder>(
   ctx: &mut Context<T>, output_file: &mut dyn Muxer, source: &mut Source<D>,
   pass1file: Option<&mut File>, pass2file: Option<&mut File>,
--- rust-rav1e-0.7.1.orig/src/bin/stats.rs
+++ rust-rav1e-0.7.1/src/bin/stats.rs
@@ -29,7 +29,6 @@ pub struct FrameSummary {
   pub enc_stats: EncoderStats,
 }
 
-#[profiling::function]
 pub fn build_frame_summary<T: Pixel>(
   packets: Packet<T>, bit_depth: usize, chroma_sampling: ChromaSampling,
   metrics_cli: MetricsEnabled,
--- rust-rav1e-0.7.1.orig/src/cdef.rs
+++ rust-rav1e-0.7.1/src/cdef.rs
@@ -321,7 +321,6 @@ fn adjust_strength(strength: i32, var: i
   }
 }
 
-#[profiling::function]
 pub fn cdef_analyze_superblock_range<T: Pixel>(
   fi: &FrameInvariants<T>, in_frame: &Frame<T>, blocks: &TileBlocks<'_>,
   sb_w: usize, sb_h: usize,
@@ -336,7 +335,6 @@ pub fn cdef_analyze_superblock_range<T:
   ret
 }
 
-#[profiling::function]
 pub fn cdef_analyze_superblock<T: Pixel>(
   fi: &FrameInvariants<T>, in_frame: &Frame<T>, blocks: &TileBlocks<'_>,
   sbo: TileSuperBlockOffset,
@@ -397,7 +395,6 @@ pub fn cdef_analyze_superblock<T: Pixel>
 /// # Panics
 ///
 /// - If called with invalid parameters
-#[profiling::function]
 pub fn cdef_filter_superblock<T: Pixel>(
   fi: &FrameInvariants<T>, input: &Frame<T>, output: &mut TileMut<'_, T>,
   blocks: &TileBlocks<'_>, tile_sbo: TileSuperBlockOffset, cdef_index: u8,
@@ -593,7 +590,6 @@ pub fn cdef_filter_superblock<T: Pixel>(
 //   tile boundary), the filtering process ignores input pixels that
 //   don't exist.
 
-#[profiling::function]
 pub fn cdef_filter_tile<T: Pixel>(
   fi: &FrameInvariants<T>, input: &Frame<T>, tb: &TileBlocks,
   output: &mut TileMut<'_, T>,
--- rust-rav1e-0.7.1.orig/src/context/block_unit.rs
+++ rust-rav1e-0.7.1/src/context/block_unit.rs
@@ -1124,7 +1124,6 @@ impl<'a> ContextWriter<'a> {
     }
   }
 
-  #[profiling::function]
   fn setup_mvref_list<T: Pixel>(
     &self, bo: TileBlockOffset, ref_frames: [RefType; 2],
     mv_stack: &mut ArrayVec<CandidateMV, 9>, bsize: BlockSize,
--- rust-rav1e-0.7.1.orig/src/deblock.rs
+++ rust-rav1e-0.7.1/src/deblock.rs
@@ -1290,7 +1290,6 @@ fn sse_h_edge<T: Pixel>(
 }
 
 // Deblocks all edges, vertical and horizontal, in a single plane
-#[profiling::function]
 pub fn deblock_plane<T: Pixel>(
   deblock: &DeblockState, p: &mut PlaneRegionMut<T>, pli: usize,
   blocks: &TileBlocks, crop_w: usize, crop_h: usize, bd: usize,
@@ -1540,7 +1539,6 @@ fn sse_plane<T: Pixel>(
 }
 
 // Deblocks all edges in all planes of a frame
-#[profiling::function]
 pub fn deblock_filter_frame<T: Pixel>(
   deblock: &DeblockState, tile: &mut TileMut<T>, blocks: &TileBlocks,
   crop_w: usize, crop_h: usize, bd: usize, planes: usize,
@@ -1616,7 +1614,6 @@ fn sse_optimize<T: Pixel>(
   level
 }
 
-#[profiling::function]
 pub fn deblock_filter_optimize<T: Pixel, U: Pixel>(
   fi: &FrameInvariants<T>, rec: &Tile<U>, input: &Tile<U>,
   blocks: &TileBlocks, crop_w: usize, crop_h: usize,
--- rust-rav1e-0.7.1.orig/src/encoder.rs
+++ rust-rav1e-0.7.1/src/encoder.rs
@@ -563,7 +563,6 @@ pub struct SegmentationState {
 }
 
 impl SegmentationState {
-  #[profiling::function]
   pub fn update_threshold(&mut self, base_q_idx: u8, bd: usize) {
     let base_ac_q = ac_q(base_q_idx, 0, bd).get() as u64;
     let real_ac_q = ArrayVec::<_, MAX_SEGMENTS>::from_iter(
@@ -741,7 +740,6 @@ impl<T: Pixel> CodedFrameData<T> {
 
   // Assumes that we have already computed activity scales and distortion scales
   // Returns -0.5 log2(mean(scale))
-  #[profiling::function]
   pub fn compute_spatiotemporal_scores(&mut self) -> i64 {
     let mut scores = self
       .distortion_scales
@@ -767,7 +765,6 @@ impl<T: Pixel> CodedFrameData<T> {
 
   // Assumes that we have already computed distortion_scales
   // Returns -0.5 log2(mean(scale))
-  #[profiling::function]
   pub fn compute_temporal_scores(&mut self) -> i64 {
     let inv_mean = DistortionScale::inv_mean(&self.distortion_scales);
     for scale in self.distortion_scales.iter_mut() {
@@ -1664,7 +1661,6 @@ pub fn encode_tx_block<T: Pixel, W: Writ
 /// # Panics
 ///
 /// - If the block size is invalid for subsampling
-#[profiling::function]
 pub fn motion_compensate<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, luma_mode: PredictionMode, ref_frames: [RefType; 2],
@@ -1893,7 +1889,6 @@ pub fn save_block_motion<T: Pixel>(
   }
 }
 
-#[profiling::function]
 pub fn encode_block_pre_cdef<T: Pixel, W: Writer>(
   seq: &Sequence, ts: &TileStateMut<'_, T>, cw: &mut ContextWriter, w: &mut W,
   bsize: BlockSize, tile_bo: TileBlockOffset, skip: bool,
@@ -1934,7 +1929,6 @@ pub fn encode_block_pre_cdef<T: Pixel, W
 ///
 /// - If chroma and luma do not match for inter modes
 /// - If an invalid motion vector is found
-#[profiling::function]
 pub fn encode_block_post_cdef<T: Pixel, W: Writer>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w: &mut W, luma_mode: PredictionMode,
@@ -2564,7 +2558,6 @@ pub fn write_tx_tree<T: Pixel, W: Writer
   (partition_has_coeff, tx_dist)
 }
 
-#[profiling::function]
 pub fn encode_block_with_modes<T: Pixel, W: Writer>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w_pre_cdef: &mut W, w_post_cdef: &mut W,
@@ -2631,7 +2624,6 @@ pub fn encode_block_with_modes<T: Pixel,
   );
 }
 
-#[profiling::function]
 fn encode_partition_bottomup<T: Pixel, W: Writer>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w_pre_cdef: &mut W, w_post_cdef: &mut W,
@@ -3234,7 +3226,6 @@ fn get_initial_cdfcontext<T: Pixel>(fi:
   cdf.unwrap_or_else(|| CDFContext::new(fi.base_q_idx))
 }
 
-#[profiling::function]
 fn encode_tile_group<T: Pixel>(
   fi: &FrameInvariants<T>, fs: &mut FrameState<T>, inter_cfg: &InterConfig,
 ) -> Vec<u8> {
@@ -3373,7 +3364,6 @@ pub struct SBSQueueEntry {
   pub w_post_cdef: WriterBase<WriterRecorder>,
 }
 
-#[profiling::function]
 fn check_lf_queue<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w: &mut WriterBase<WriterEncoder>,
@@ -3465,7 +3455,6 @@ fn check_lf_queue<T: Pixel>(
   }
 }
 
-#[profiling::function]
 fn encode_tile<'a, T: Pixel>(
   fi: &FrameInvariants<T>, ts: &'a mut TileStateMut<'_, T>,
   fc: &'a mut CDFContext, blocks: &'a mut TileBlocksMut<'a>,
@@ -3690,7 +3679,6 @@ fn write_tile_group_header(tile_start_an
 /// # Panics
 ///
 /// - If the frame packets cannot be written
-#[profiling::function]
 pub fn encode_show_existing_frame<T: Pixel>(
   fi: &FrameInvariants<T>, fs: &mut FrameState<T>, inter_cfg: &InterConfig,
 ) -> Vec<u8> {
@@ -3765,7 +3753,6 @@ fn get_initial_segmentation<T: Pixel>(
 /// # Panics
 ///
 /// - If the frame packets cannot be written
-#[profiling::function]
 pub fn encode_frame<T: Pixel>(
   fi: &FrameInvariants<T>, fs: &mut FrameState<T>, inter_cfg: &InterConfig,
 ) -> Vec<u8> {
--- rust-rav1e-0.7.1.orig/src/lrf.rs
+++ rust-rav1e-0.7.1/src/lrf.rs
@@ -525,7 +525,6 @@ impl<'a, T: Pixel> Iterator for HorzPadd
 impl<T: Pixel> ExactSizeIterator for HorzPaddedIter<'_, T> {}
 impl<T: Pixel> FusedIterator for HorzPaddedIter<'_, T> {}
 
-#[profiling::function]
 pub fn setup_integral_image<T: Pixel>(
   integral_image_buffer: &mut IntegralImageBuffer,
   integral_image_stride: usize, crop_w: usize, crop_h: usize, stripe_w: usize,
@@ -625,7 +624,6 @@ pub fn setup_integral_image<T: Pixel>(
   }
 }
 
-#[profiling::function]
 pub fn sgrproj_stripe_filter<T: Pixel, U: Pixel>(
   set: u8, xqd: [i8; 2], fi: &FrameInvariants<T>,
   integral_image_buffer: &IntegralImageBuffer, integral_image_stride: usize,
@@ -842,7 +840,6 @@ pub fn sgrproj_stripe_filter<T: Pixel, U
 
 // Input params follow the same rules as sgrproj_stripe_filter.
 // Inputs are relative to the colocated slice views.
-#[profiling::function]
 pub fn sgrproj_solve<T: Pixel>(
   set: u8, fi: &FrameInvariants<T>,
   integral_image_buffer: &IntegralImageBuffer, input: &PlaneRegion<'_, T>,
@@ -1094,7 +1091,6 @@ pub fn sgrproj_solve<T: Pixel>(
   }
 }
 
-#[profiling::function]
 fn wiener_stripe_filter<T: Pixel>(
   coeffs: [[i8; 3]; 2], fi: &FrameInvariants<T>, crop_w: usize, crop_h: usize,
   stripe_w: usize, stripe_h: usize, stripe_x: usize, stripe_y: isize,
@@ -1483,7 +1479,6 @@ impl RestorationState {
     }
   }
 
-  #[profiling::function]
   pub fn lrf_filter_frame<T: Pixel>(
     &mut self, out: &mut Frame<T>, pre_cdef: &Frame<T>,
     fi: &FrameInvariants<T>,
--- rust-rav1e-0.7.1.orig/src/me.rs
+++ rust-rav1e-0.7.1/src/me.rs
@@ -382,7 +382,6 @@ impl MotionEstimationSubsets {
   }
 }
 
-#[profiling::function]
 fn get_subset_predictors(
   tile_bo: TileBlockOffset, tile_me_stats: &TileMEStats<'_>,
   frame_ref_opt: Option<ReadGuardMEStats<'_>>, ref_frame_id: usize,
@@ -689,7 +688,6 @@ fn refine_subsampled_motion_estimate<T:
   }
 }
 
-#[profiling::function]
 fn full_pixel_me<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &TileStateMut<'_, T>,
   org_region: &PlaneRegion<T>, p_ref: &Plane<T>, tile_bo: TileBlockOffset,
@@ -880,7 +878,6 @@ fn sub_pixel_me<T: Pixel>(
   );
 }
 
-#[profiling::function]
 fn get_best_predictor<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   p_ref: &Plane<T>, predictors: &[MotionVector], bit_depth: usize,
@@ -951,7 +948,6 @@ const DIAMOND_R1_PATTERN: [MotionVector;
 /// For each step size, candidate motion vectors are examined for improvement
 /// to the current search location. The search location is moved to the best
 /// candidate (if any). This is repeated until the search location stops moving.
-#[profiling::function]
 fn fullpel_diamond_search<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   p_ref: &Plane<T>, current: &mut MotionSearchResult, bit_depth: usize,
@@ -1051,7 +1047,6 @@ const SQUARE_REFINE_PATTERN: [MotionVect
 ///
 /// `current` provides the initial search location and serves as
 /// the output for the final search results.
-#[profiling::function]
 fn hexagon_search<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   p_ref: &Plane<T>, current: &mut MotionSearchResult, bit_depth: usize,
@@ -1166,7 +1161,6 @@ const UMH_PATTERN: [MotionVector; 16] =
 /// the output for the final search results.
 ///
 /// `me_range` parameter determines how far these stages can search.
-#[profiling::function]
 fn uneven_multi_hex_search<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   p_ref: &Plane<T>, current: &mut MotionSearchResult, bit_depth: usize,
@@ -1307,7 +1301,6 @@ fn uneven_multi_hex_search<T: Pixel>(
 /// For each step size, candidate motion vectors are examined for improvement
 /// to the current search location. The search location is moved to the best
 /// candidate (if any). This is repeated until the search location stops moving.
-#[profiling::function]
 fn subpel_diamond_search<T: Pixel>(
   fi: &FrameInvariants<T>, po: PlaneOffset, org_region: &PlaneRegion<T>,
   _p_ref: &Plane<T>, bit_depth: usize, pmv: [MotionVector; 2], lambda: u32,
@@ -1460,7 +1453,6 @@ fn compute_mv_rd<T: Pixel>(
   MVCandidateRD { cost: 256 * sad as u64 + rate as u64 * lambda as u64, sad }
 }
 
-#[profiling::function]
 fn full_search<T: Pixel>(
   fi: &FrameInvariants<T>, x_lo: isize, x_hi: isize, y_lo: isize, y_hi: isize,
   w: usize, h: usize, org_region: &PlaneRegion<T>, p_ref: &Plane<T>,
--- rust-rav1e-0.7.1.orig/src/rate.rs
+++ rust-rav1e-0.7.1/src/rate.rs
@@ -719,7 +719,6 @@ impl RCState {
   }
 
   // TODO: Separate quantizers for Cb and Cr.
-  #[profiling::function]
   pub(crate) fn select_qi<T: Pixel>(
     &self, ctx: &ContextInner<T>, output_frameno: u64, fti: usize,
     maybe_prev_log_base_q: Option<i64>, log_isqrt_mean_scale: i64,
@@ -1068,7 +1067,6 @@ impl RCState {
     (log_base_q, log_q)
   }
 
-  #[profiling::function]
   pub fn update_state(
     &mut self, bits: i64, fti: usize, show_frame: bool, log_target_q: i64,
     trial: bool, droppable: bool,
--- rust-rav1e-0.7.1.orig/src/rdo.rs
+++ rust-rav1e-0.7.1/src/rdo.rs
@@ -810,7 +810,6 @@ const fn dmv_in_range(mv: MotionVector,
 }
 
 #[inline]
-#[profiling::function]
 fn luma_chroma_mode_rdo<T: Pixel>(
   luma_mode: PredictionMode, fi: &FrameInvariants<T>, bsize: BlockSize,
   tile_bo: TileBlockOffset, ts: &mut TileStateMut<'_, T>,
@@ -957,7 +956,6 @@ fn luma_chroma_mode_rdo<T: Pixel>(
 ///
 /// - If the best RD found is negative.
 ///   This should never happen and indicates a development error.
-#[profiling::function]
 pub fn rdo_mode_decision<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, bsize: BlockSize, tile_bo: TileBlockOffset,
@@ -1115,7 +1113,6 @@ pub fn rdo_mode_decision<T: Pixel>(
   }
 }
 
-#[profiling::function]
 fn inter_frame_rdo_mode_decision<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, bsize: BlockSize, tile_bo: TileBlockOffset,
@@ -1388,7 +1385,6 @@ fn inter_frame_rdo_mode_decision<T: Pixe
   best
 }
 
-#[profiling::function]
 fn intra_frame_rdo_mode_decision<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, bsize: BlockSize, tile_bo: TileBlockOffset,
@@ -1587,7 +1583,6 @@ fn intra_frame_rdo_mode_decision<T: Pixe
 /// # Panics
 ///
 /// - If the block size is invalid for subsampling.
-#[profiling::function]
 pub fn rdo_cfl_alpha<T: Pixel>(
   ts: &mut TileStateMut<'_, T>, tile_bo: TileBlockOffset, bsize: BlockSize,
   luma_tx_size: TxSize, fi: &FrameInvariants<T>,
@@ -1943,7 +1938,6 @@ fn rdo_partition_simple<T: Pixel, W: Wri
 ///
 /// - If the best RD found is negative.
 ///   This should never happen, and indicates a development error.
-#[profiling::function]
 pub fn rdo_partition_decision<T: Pixel, W: Writer>(
   fi: &FrameInvariants<T>, ts: &mut TileStateMut<'_, T>,
   cw: &mut ContextWriter, w_pre_cdef: &mut W, w_post_cdef: &mut W,
@@ -2021,7 +2015,6 @@ pub fn rdo_partition_decision<T: Pixel,
   }
 }
 
-#[profiling::function]
 fn rdo_loop_plane_error<T: Pixel>(
   base_sbo: TileSuperBlockOffset, offset_sbo: TileSuperBlockOffset,
   sb_w: usize, sb_h: usize, fi: &FrameInvariants<T>, ts: &TileStateMut<'_, T>,
@@ -2098,7 +2091,6 @@ fn rdo_loop_plane_error<T: Pixel>(
 /// # Panics
 ///
 /// - If both CDEF and LRF are disabled.
-#[profiling::function]
 pub fn rdo_loop_decision<T: Pixel, W: Writer>(
   base_sbo: TileSuperBlockOffset, fi: &FrameInvariants<T>,
   ts: &mut TileStateMut<'_, T>, cw: &mut ContextWriter, w: &mut W,
--- rust-rav1e-0.7.1.orig/src/scenechange/fast.rs
+++ rust-rav1e-0.7.1/src/scenechange/fast.rs
@@ -18,7 +18,6 @@ pub(super) const FAST_THRESHOLD: f64 = 1
 impl<T: Pixel> SceneChangeDetector<T> {
   /// The fast algorithm detects fast cuts using a raw difference
   /// in pixel values between the scaled frames.
-  #[profiling::function]
   pub(super) fn fast_scenecut(
     &mut self, frame1: Arc<Frame<T>>, frame2: Arc<Frame<T>>,
   ) -> ScenecutResult {
@@ -67,7 +66,6 @@ impl<T: Pixel> SceneChangeDetector<T> {
   }
 
   /// Calculates the average sum of absolute difference (SAD) per pixel between 2 planes
-  #[profiling::function]
   fn delta_in_planes(&self, plane1: &Plane<T>, plane2: &Plane<T>) -> f64 {
     let delta = sad_plane::sad_plane(plane1, plane2, self.cpu_feature_level);
 
--- rust-rav1e-0.7.1.orig/src/scenechange/mod.rs
+++ rust-rav1e-0.7.1/src/scenechange/mod.rs
@@ -149,7 +149,6 @@ impl<T: Pixel> SceneChangeDetector<T> {
   /// to the second frame in `frame_set`.
   ///
   /// This will gracefully handle the first frame in the video as well.
-  #[profiling::function]
   pub fn analyze_next_frame(
     &mut self, frame_set: &[&Arc<Frame<T>>], input_frameno: u64,
     previous_keyframe: u64,
--- rust-rav1e-0.7.1.orig/src/segmentation.rs
+++ rust-rav1e-0.7.1/src/segmentation.rs
@@ -19,7 +19,6 @@ use crate::FrameState;
 
 pub const MAX_SEGMENTS: usize = 8;
 
-#[profiling::function]
 pub fn segmentation_optimize<T: Pixel>(
   fi: &FrameInvariants<T>, fs: &mut FrameState<T>,
 ) {
@@ -159,7 +158,6 @@ fn segmentation_optimize_inner<T: Pixel>
   fs.segmentation.update_threshold(fi.base_q_idx, fi.config.bit_depth);
 }
 
-#[profiling::function]
 pub fn select_segment<T: Pixel>(
   fi: &FrameInvariants<T>, ts: &TileStateMut<'_, T>, tile_bo: TileBlockOffset,
   bsize: BlockSize, skip: bool,
