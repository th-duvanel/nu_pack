This patch fixes the tests if the allocator-api2 feature is disabled.

Index: hashbrown/src/map.rs
===================================================================
--- hashbrown.orig/src/map.rs
+++ hashbrown/src/map.rs
@@ -6711,6 +6711,7 @@ mod test_map {
     use super::{HashMap, RawEntryMut};
     use alloc::string::{String, ToString};
     use alloc::sync::Arc;
+    #[cfg(feature="allocator-api2")]
     use allocator_api2::alloc::{AllocError, Allocator, Global};
     use core::alloc::Layout;
     use core::ptr::NonNull;
@@ -8590,6 +8656,7 @@ mod test_map {
         }
     }
 
+    #[cfg(feature="allocator-api2")]
     unsafe impl Allocator for MyAlloc {
         fn allocate(&self, layout: Layout) -> std::result::Result<NonNull<[u8]>, AllocError> {
             let g = Global;
@@ -8603,6 +8670,7 @@ mod test_map {
     }
 
     #[test]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_hashmap_into_iter_bug() {
         let dropped: Arc<AtomicI8> = Arc::new(AtomicI8::new(1));
 
@@ -8673,6 +8741,7 @@ mod test_map {
     ///
     /// This function does not panic, but returns an error as a `String`
     /// to distinguish between a test panic and an error in the input data.
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn get_test_map<I, T, A>(
         iter: I,
         mut fun: impl FnMut(u64) -> T,
@@ -8768,6 +8837,7 @@ mod test_map {
 
     #[test]
     #[should_panic = "panic in clone"]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_clone_memory_leaks_and_double_drop_one() {
         let dropped: Arc<AtomicI8> = Arc::new(AtomicI8::new(2));
 
@@ -8794,6 +8864,7 @@ mod test_map {
 
     #[test]
     #[should_panic = "panic in drop"]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_clone_memory_leaks_and_double_drop_two() {
         let dropped: Arc<AtomicI8> = Arc::new(AtomicI8::new(2));
 
@@ -8828,6 +8899,7 @@ mod test_map {
     /// We check that we have a working table if the clone operation from another
     /// thread ended in a panic (when buckets of maps are equal to each other).
     #[test]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_catch_panic_clone_from_when_len_is_equal() {
         use std::thread;
 
@@ -8893,6 +8965,7 @@ mod test_map {
     /// We check that we have a working table if the clone operation from another
     /// thread ended in a panic (when buckets of maps are not equal to each other).
     #[test]
+    #[cfg(all(feature="allocator-api2", feature="ahash"))]
     fn test_catch_panic_clone_from_when_len_is_not_equal() {
         use std::thread;
 
Index: hashbrown/src/raw/mod.rs
===================================================================
--- hashbrown.orig/src/raw/mod.rs
+++ hashbrown/src/raw/mod.rs
@@ -4671,9 +4673,11 @@ mod test_map {
     /// CHECKING THAT WE DON'T TRY TO DROP DATA IF THE `ITEMS`
     /// ARE ZERO, EVEN IF WE HAVE `FULL` CONTROL BYTES.
     #[test]
+    #[cfg(feature="allocator-api2")]
     fn test_catch_panic_clone_from() {
         use ::alloc::sync::Arc;
         use ::alloc::vec::Vec;
+        #[cfg(feature="allocator-api2")]
         use allocator_api2::alloc::{AllocError, Allocator, Global};
         use core::sync::atomic::{AtomicI8, Ordering};
         use std::thread;
@@ -4694,6 +4698,7 @@ mod test_map {
             }
         }
 
+        #[cfg(feature="allocator-api2")]
         unsafe impl Allocator for MyAlloc {
             fn allocate(&self, layout: Layout) -> std::result::Result<NonNull<[u8]>, AllocError> {
                 let g = Global;
