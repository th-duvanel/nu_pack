Index: ring/src/aead/aes.rs
===================================================================
--- ring.orig/src/aead/aes.rs
+++ ring/src/aead/aes.rs
@@ -437,6 +437,7 @@ fn detect_implementation(cpu_features: c
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::*;
     use crate::test;
Index: ring/src/aead/poly1305.rs
===================================================================
--- ring.orig/src/aead/poly1305.rs
+++ ring/src/aead/poly1305.rs
@@ -130,6 +130,7 @@ pub(super) fn sign(key: Key, input: &[u8
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::*;
     use crate::test;
Index: ring/src/ec/suite_b/ecdsa/digest_scalar.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/digest_scalar.rs
+++ ring/src/ec/suite_b/ecdsa/digest_scalar.rs
@@ -75,6 +75,7 @@ fn digest_scalar_(ops: &ScalarOps, diges
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use super::digest_bytes_scalar;
     use crate::{
Index: ring/src/ec/suite_b/ecdsa/signing.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/signing.rs
+++ ring/src/ec/suite_b/ecdsa/signing.rs
@@ -513,6 +513,7 @@ static EC_PUBLIC_KEY_P384_PKCS8_V1_TEMPL
 };
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use crate::{rand, signature, test};
 
Index: ring/src/ec/suite_b/ecdsa/verification.rs
===================================================================
--- ring.orig/src/ec/suite_b/ecdsa/verification.rs
+++ ring/src/ec/suite_b/ecdsa/verification.rs
@@ -276,6 +276,7 @@ pub static ECDSA_P384_SHA384_ASN1: Ecdsa
 };
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     extern crate alloc;
     use super::*;
Index: ring/src/ec/suite_b/ops.rs
===================================================================
--- ring.orig/src/ec/suite_b/ops.rs
+++ ring/src/ec/suite_b/ops.rs
@@ -471,10 +471,12 @@ mod tests {
         elem_add_test(
             &p256::PUBLIC_SCALAR_OPS,
             test_file!("ops/p256_elem_sum_tests.txt"),
+    #[cfg(feature = "alloc")]
         );
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_add_test() {
         elem_add_test(
             &p384::PUBLIC_SCALAR_OPS,
@@ -482,6 +484,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_add_test(ops: &PublicScalarOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -507,6 +510,7 @@ mod tests {
     // the point arithmetic functions. Thus, we can't test it.
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_sub_test() {
         prefixed_extern! {
             fn p384_elem_sub(r: *mut Limb, a: *const Limb, b: *const Limb);
@@ -518,6 +522,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_sub_test(
         ops: &CommonOps,
         elem_sub: unsafe extern "C" fn(r: *mut Limb, a: *const Limb, b: *const Limb),
@@ -558,6 +563,7 @@ mod tests {
     // into the point arithmetic functions. Thus, we can't test it.
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_div_by_2_test() {
         prefixed_extern! {
             fn p384_elem_div_by_2(r: *mut Limb, a: *const Limb);
@@ -569,6 +575,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_div_by_2_test(
         ops: &CommonOps,
         elem_div_by_2: unsafe extern "C" fn(r: *mut Limb, a: *const Limb),
@@ -593,6 +600,7 @@ mod tests {
     // There is no `ecp_nistz256_neg` on other targets.
     /* #[cfg(target_arch = "x86_64")]
     #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_neg_test() {
         prefixed_extern! {
             fn ecp_nistz256_neg(r: *mut Limb, a: *const Limb);
@@ -605,6 +613,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_neg_test() {
         prefixed_extern! {
             fn p384_elem_neg(r: *mut Limb, a: *const Limb);
@@ -616,6 +625,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_neg_test(
         ops: &CommonOps,
         elem_neg: unsafe extern "C" fn(r: *mut Limb, a: *const Limb),
@@ -650,15 +660,18 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_elem_mul_test() {
         elem_mul_test(&p256::COMMON_OPS, test_file!("ops/p256_elem_mul_tests.txt"));
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_elem_mul_test() {
         elem_mul_test(&p384::COMMON_OPS, test_file!("ops/p384_elem_mul_tests.txt"));
     } */
 
+    #[cfg(feature = "alloc")]
     fn elem_mul_test(ops: &CommonOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -674,6 +687,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_scalar_mul_test() {
         scalar_mul_test(
             &p256::SCALAR_OPS,
@@ -682,6 +696,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_scalar_mul_test() {
         scalar_mul_test(
             &p384::SCALAR_OPS,
@@ -689,6 +704,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn scalar_mul_test(ops: &ScalarOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -704,6 +720,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_scalar_square_test() {
         prefixed_extern! {
             fn p256_scalar_sqr_rep_mont(r: *mut Limb, a: *const Limb, rep: Limb);
@@ -718,6 +735,7 @@ mod tests {
     // XXX: There's no `p384_scalar_square_test()` because there's no dedicated
     // `p384_scalar_sqr_rep_mont()`.
 
+    #[cfg(feature = "alloc")]
     fn scalar_square_test(
         ops: &ScalarOps,
         sqr_rep: unsafe extern "C" fn(r: *mut Limb, a: *const Limb, rep: Limb),
@@ -763,6 +781,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_sum_test() {
         point_sum_test(
             &p256::PRIVATE_KEY_OPS,
@@ -771,6 +790,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_sum_test() {
         point_sum_test(
             &p384::PRIVATE_KEY_OPS,
@@ -778,6 +798,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_sum_test(ops: &PrivateKeyOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -798,6 +819,7 @@ mod tests {
         prefixed_extern! {
             fn p256_point_add_affine(
                 r: *mut Limb,   // [p256::COMMON_OPS.num_limbs*3]
+    #[cfg(feature = "alloc")]
                 a: *const Limb, // [p256::COMMON_OPS.num_limbs*3]
                 b: *const Limb, // [p256::COMMON_OPS.num_limbs*2]
             );
@@ -811,6 +833,7 @@ mod tests {
 
     // XXX: There is no `nistz384_point_add_affine()`.
 
+    #[cfg(feature = "alloc")]
     fn point_sum_mixed_test(
         ops: &PrivateKeyOps,
         point_add_affine: unsafe extern "C" fn(
@@ -839,6 +862,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_double_test() {
         prefixed_extern! {
             fn p256_point_double(
@@ -854,6 +878,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_double_test() {
         prefixed_extern! {
             fn p384_point_double(
@@ -868,6 +893,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_double_test(
         ops: &PrivateKeyOps,
         point_double: unsafe extern "C" fn(
@@ -894,6 +920,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_test() {
         point_mul_tests(
             &p256::PRIVATE_KEY_OPS,
@@ -902,6 +929,7 @@ mod tests {
     } */
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_mul_test() {
         point_mul_tests(
             &p384::PRIVATE_KEY_OPS,
@@ -909,6 +937,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_mul_tests(ops: &PrivateKeyOps, test_file: test::File) {
         test::run(test_file, |section, test_case| {
             assert_eq!(section, "");
@@ -927,6 +956,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_serialized_test() {
         point_mul_serialized_test(
             &p256::PRIVATE_KEY_OPS,
@@ -935,6 +965,7 @@ mod tests {
         );
     } */
 
+    #[cfg(feature = "alloc")]
     fn point_mul_serialized_test(
         priv_ops: &PrivateKeyOps,
         pub_ops: &PublicKeyOps,
@@ -976,6 +1007,7 @@ mod tests {
     }
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p256_point_mul_base_test() {
         point_mul_base_tests(
             &p256::PRIVATE_KEY_OPS,
@@ -985,6 +1017,7 @@ mod tests {
     }*/
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn p384_point_mul_base_test() {
         point_mul_base_tests(
             &p384::PRIVATE_KEY_OPS,
@@ -994,4 +1027,5 @@ mod tests {
     }*/
 
+    #[cfg(feature = "alloc")]
     pub(super) fn point_mul_base_tests(
         ops: &PrivateKeyOps,
@@ -1037,6 +1071,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_jacobian_point(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1056,6 +1091,7 @@ mod tests {
         xy: [Limb; 2 * MAX_LIMBS],
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_affine_point(
         ops: &PrivateKeyOps,
         test_case: &mut test::TestCase,
@@ -1072,6 +1108,7 @@ mod tests {
         p
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_point_elem(ops: &CommonOps, limbs_out: &mut [Limb], elems: &[&str], i: usize) {
         let bytes = test::from_hex(elems[i]).unwrap();
         let bytes = untrusted::Input::from(&bytes);
@@ -1086,6 +1123,7 @@ mod tests {
         Affine(Elem<R>, Elem<R>),
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_point(ops: &PrivateKeyOps, test_case: &mut test::TestCase, name: &str) -> TestPoint {
         fn consume_point_elem(ops: &CommonOps, elems: &[&str], i: usize) -> Elem<R> {
             let bytes = test::from_hex(elems[i]).unwrap();
@@ -1136,6 +1174,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_elem(ops: &CommonOps, test_case: &mut test::TestCase, name: &str) -> Elem<R> {
         let bytes = consume_padded_bytes(ops, test_case, name);
         let bytes = untrusted::Input::from(&bytes);
@@ -1148,12 +1187,14 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_scalar(ops: &CommonOps, test_case: &mut test::TestCase, name: &str) -> Scalar {
         let bytes = test_case.consume_bytes(name);
         let bytes = untrusted::Input::from(&bytes);
         scalar_parse_big_endian_variable(ops, AllowZero::Yes, bytes).unwrap()
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_scalar_mont(
         ops: &CommonOps,
         test_case: &mut test::TestCase,
@@ -1170,6 +1211,7 @@ mod tests {
         }
     }
 
+    #[cfg(feature = "alloc")]
     fn consume_padded_bytes(
         ops: &CommonOps,
         test_case: &mut test::TestCase,
Index: ring/src/ec/suite_b/public_key.rs
===================================================================
--- ring.orig/src/ec/suite_b/public_key.rs
+++ ring/src/ec/suite_b/public_key.rs
@@ -70,6 +70,7 @@ mod tests {
     use crate::test;
 
     /* #[test]
+    #[cfg(feature = "alloc")]
     fn parse_uncompressed_point_test() {
         test::run(
             test_file!("suite_b_public_key_tests.txt"),
Index: ring/tests/aead_tests.rs
===================================================================
--- ring.orig/tests/aead_tests.rs
+++ ring/tests/aead_tests.rs
@@ -19,10 +19,14 @@ use wasm_bindgen_test::{wasm_bindgen_tes
 wasm_bindgen_test_configure!(run_in_browser);
 
 use core::ops::RangeFrom;
-use ring::{aead, error, test, test_file};
+use ring::{aead, error, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 /// Generate the known answer test functions for the given algorithm and test
 /// case input file, where each test is implemented by a test in `$test`.
+#[cfg(feature = "alloc")]
 ///
 /// All of these tests can be run in parallel.
 macro_rules! test_known_answer {
@@ -42,6 +46,7 @@ macro_rules! test_known_answer {
 /// Generate the tests for a given algorithm.
 ///
 /// All of these tests can be run in parallel.
+#[cfg(feature = "alloc")]
 macro_rules! test_aead {
     { $( { $alg:ident, $test_file:expr } ),+, } => {
         mod aead_test { // Make `cargo test aead` include these files.
@@ -78,7 +83,8 @@ macro_rules! test_aead {
     }
 }
 
-/*test_aead! {
+/*#[cfg(feature = "alloc")]
+test_aead! {
     { AES_128_GCM, "aead_aes_128_gcm_tests.txt" },
     { AES_256_GCM, "aead_aes_256_gcm_tests.txt" },
     { CHACHA20_POLY1305, "aead_chacha20_poly1305_tests.txt" },
@@ -443,6 +449,7 @@ fn test_aead_nonce_sizes() {
 
 /* #[allow(clippy::range_plus_one)]
 #[test]
+#[cfg(feature = "alloc")]
 fn aead_chacha20_poly1305_openssh() {
     // TODO: test_aead_key_sizes(...);
 
Index: ring/tests/agreement_tests.rs
===================================================================
--- ring.orig/tests/agreement_tests.rs
+++ ring/tests/agreement_tests.rs
@@ -20,7 +20,10 @@ wasm_bindgen_test_configure!(run_in_brow
 
 extern crate alloc;
 
-use ring::{agreement, error, rand, test, test_file};
+use ring::{agreement, error, rand, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[test]
 fn agreement_traits() {
@@ -69,6 +72,7 @@ fn agreement_traits() {
 }
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn agreement_agree_ephemeral() {
     let rng = rand::SystemRandom::new();
 
@@ -126,6 +130,7 @@ fn agreement_agree_ephemeral() {
 } */
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_agreement_ecdh_x25519_rfc_iterated() {
     let mut k = h("0900000000000000000000000000000000000000000000000000000000000000");
     let mut u = k.clone();
@@ -190,6 +195,7 @@ fn x25519_(private_key: &[u8], public_ke
     })
 }
 
+#[cfg(feature = "alloc")]
 fn h(s: &str) -> Vec<u8> {
     match test::from_hex(s) {
         Ok(v) => v,
Index: ring/tests/digest_tests.rs
===================================================================
--- ring.orig/tests/digest_tests.rs
+++ ring/tests/digest_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, test, test_file};
+use ring::{digest, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -23,6 +26,7 @@ wasm_bindgen_test_configure!(run_in_brow
 /// Test vectors from BoringSSL, Go, and other sources.
 /* #[test]
 fn digest_misc() {
+#[cfg(feature = "alloc")]
     test::run(test_file!("digest_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
         let digest_alg = test_case.consume_digest_alg("Hash").unwrap();
@@ -46,6 +50,7 @@ fn digest_misc() {
     });
 } */
 
+#[cfg(feature = "alloc")]
 mod digest_shavs {
     use ring::{digest, test};
 
@@ -84,6 +89,7 @@ mod digest_shavs {
 
                 #[test]
                 fn short_msg_known_answer_test() {
+                #[cfg(feature = "alloc")]
                     run_known_answer_test(
                         &digest::$algorithm_name,
                         test_file!(concat!(
@@ -97,6 +103,7 @@ mod digest_shavs {
                 #[test]
                 fn long_msg_known_answer_test() {
                     run_known_answer_test(
+                #[cfg(feature = "alloc")]
                         &digest::$algorithm_name,
                         test_file!(concat!(
                             "../third_party/NIST/SHAVS/",
@@ -110,6 +117,7 @@ mod digest_shavs {
                 fn monte_carlo_test() {
                     run_monte_carlo_test(
                         &digest::$algorithm_name,
+                #[cfg(feature = "alloc")]
                         test_file!(concat!(
                             "../third_party/NIST/SHAVS/",
                             stringify!($file_name),
Index: ring/tests/ecdsa_tests.rs
===================================================================
--- ring.orig/tests/ecdsa_tests.rs
+++ ring/tests/ecdsa_tests.rs
@@ -15,12 +15,16 @@
 use ring::{
     rand,
     signature::{self, KeyPair},
-    test, test_file,
+    test,
 };
 
+#[cfg(feature = "alloc")]
+use ring::test_file;
+
 // ECDSA *signing* tests are in src/ec/ecdsa/signing.rs.
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn ecdsa_from_pkcs8_test() {
     let rng = rand::SystemRandom::new();
 
@@ -111,6 +115,7 @@ fn ecdsa_generate_pkcs8_test() {
 }
 
 /* #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_verify_asn1_test() {
     test::run(
         test_file!("ecdsa_verify_asn1_tests.txt"),
@@ -144,6 +149,7 @@ fn signature_ecdsa_verify_asn1_test() {
 } 
 
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_verify_fixed_test() {
     test::run(
         test_file!("ecdsa_verify_fixed_tests.txt"),
@@ -215,6 +221,7 @@ fn ecdsa_test_public_key_coverage() {
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
 /* #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_sign_fixed_sign_and_verify_test() {
     let rng = rand::SystemRandom::new();
 
@@ -269,6 +276,7 @@ fn signature_ecdsa_sign_fixed_sign_and_v
 // signature verifies correctly. The known-answer tests themselves are in
 // ecsda/signing.rs.
 #[test]
+#[cfg(feature = "alloc")]
 fn signature_ecdsa_sign_asn1_test() {
     let rng = rand::SystemRandom::new();
 
Index: ring/tests/ed25519_tests.rs
===================================================================
--- ring.orig/tests/ed25519_tests.rs
+++ ring/tests/ed25519_tests.rs
@@ -15,9 +15,12 @@
 use ring::{
     error, rand,
     signature::{self, Ed25519KeyPair, KeyPair},
-    test, test_file,
+    test,
 };
 
+#[cfg(feature = "alloc")]
+use ring::test_file;
+
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
 
@@ -26,6 +29,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 /* /// Test vectors from BoringSSL.
 #[test]
+#[cfg(feature = "alloc")]
 fn test_signature_ed25519() {
     test::run(test_file!("ed25519_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
@@ -89,6 +93,7 @@ fn test_signature_ed25519_verify() {
     );
 }*/
 
+#[cfg(feature = "alloc")]
 fn test_signature_verification(
     public_key: &[u8],
     msg: &[u8],
@@ -132,6 +137,7 @@ fn test_ed25519_from_pkcs8_unchecked() {
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn test_ed25519_from_pkcs8() {
     test_ed25519_from_pkcs8_(FromPkcs8Variant::Checked, Ed25519KeyPair::from_pkcs8)
 }
Index: ring/tests/hmac_tests.rs
===================================================================
--- ring.orig/tests/hmac_tests.rs
+++ ring/tests/hmac_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, hmac, test, test_file};
+use ring::{digest, hmac, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -22,6 +25,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 /*#[test]
 fn hmac_tests() {
+#[cfg(feature = "alloc")]
     test::run(test_file!("hmac_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
         let digest_alg = test_case.consume_digest_alg("HMAC");
Index: ring/tests/pbkdf2_tests.rs
===================================================================
--- ring.orig/tests/pbkdf2_tests.rs
+++ ring/tests/pbkdf2_tests.rs
@@ -13,7 +13,10 @@
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 use core::num::NonZeroU32;
-use ring::{digest, error, pbkdf2, test, test_file};
+use ring::{digest, error, pbkdf2, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -24,6 +27,7 @@ wasm_bindgen_test_configure!(run_in_brow
 /* /// Test vectors from BoringSSL, Go, and other sources.
 #[test]
 pub fn pbkdf2_tests() {
+#[cfg(feature = "alloc")]
     test::run(test_file!("pbkdf2_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
         let algorithm = {
Index: ring/tests/quic_tests.rs
===================================================================
--- ring.orig/tests/quic_tests.rs
+++ ring/tests/quic_tests.rs
@@ -12,23 +12,30 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{aead::quic, test, test_file};
+use ring::{aead::quic, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 /* #[test]
 fn quic_aes_128() {
     test_quic(&quic::AES_128, test_file!("quic_aes_128_tests.txt"));
 }
+#[cfg(feature = "alloc")]
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_aes_256() {
     test_quic(&quic::AES_256, test_file!("quic_aes_256_tests.txt"));
 }
 
 #[test]
+#[cfg(feature = "alloc")]
 fn quic_chacha20() {
     test_quic(&quic::CHACHA20, test_file!("quic_chacha20_tests.txt"));
 }*/
 
+#[cfg(feature = "alloc")]
 fn test_quic(alg: &'static quic::Algorithm, test_file: test::File) {
     test_sample_len(alg);
 
Index: ring/src/lib.rs
===================================================================
--- ring.orig/src/lib.rs
+++ ring/src/lib.rs
@@ -52,7 +52,7 @@
 #![forbid(unused_results)]
 #![no_std]
 
-#[cfg(feature = "alloc")]
+#[cfg(any(feature = "alloc",test))]
 extern crate alloc;
 
 #[macro_use]
Index: ring/src/limb.rs
===================================================================
--- ring.orig/src/limb.rs
+++ ring/src/limb.rs
@@ -375,6 +375,7 @@ mod tests {
     const MAX: Limb = LimbMask::True as Limb;
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_are_even() {
         static EVENS: &[&[Limb]] = &[
             &[],
@@ -438,6 +439,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_equal_limb() {
         for zero in ZEROES {
             assert_eq!(limbs_equal_limb_constant_time(zero, 0), LimbMask::True);
@@ -601,6 +603,7 @@ mod tests {
     }
 
     #[test]
+    #[cfg(feature = "alloc")]
     fn test_limbs_minimal_bits() {
         const ALL_ONES: Limb = LimbMask::True as Limb;
         static CASES: &[(&[Limb], usize)] = &[
Index: ring/src/test.rs
===================================================================
--- ring.orig/src/test.rs
+++ ring/src/test.rs
@@ -542,6 +542,7 @@ pub mod rand {
 }
 
 #[cfg(test)]
+#[cfg(feature = "alloc")]
 mod tests {
     use crate::{error, test};
 
Index: ring/tests/hkdf_tests.rs
===================================================================
--- ring.orig/tests/hkdf_tests.rs
+++ ring/tests/hkdf_tests.rs
@@ -12,7 +12,10 @@
 // OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 // CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-use ring::{digest, error, hkdf, test, test_file};
+use ring::{digest, error, hkdf, test};
+
+#[cfg(feature = "alloc")]
+use ring::test_file;
 
 #[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
 use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};
@@ -22,6 +25,7 @@ wasm_bindgen_test_configure!(run_in_brow
 
 /* #[test]
 fn hkdf_tests() {
+#[cfg(feature = "alloc")]
     test::run(test_file!("hkdf_tests.txt"), |section, test_case| {
         assert_eq!(section, "");
         let alg = {
