Index: signal-hook/examples/print.rs
===================================================================
--- signal-hook.orig/examples/print.rs
+++ signal-hook/examples/print.rs
@@ -3,15 +3,17 @@ use signal_hook::consts::signal::*;
 use signal_hook::low_level;
 
 use std::io::Error;
+use std::io::ErrorKind;
 
 #[cfg(feature = "extended-siginfo")]
 type Signals =
     signal_hook::iterator::SignalsInfo<signal_hook::iterator::exfiltrator::origin::WithOrigin>;
 
-#[cfg(not(feature = "extended-siginfo"))]
+#[cfg(feature = "iterator")]#[cfg(not(feature = "extended-siginfo"))]
 use signal_hook::iterator::Signals;
 
 fn main() -> Result<(), Error> {
+  #[cfg(feature = "iterator")] {
     const SIGNALS: &[c_int] = &[
         SIGTERM, SIGQUIT, SIGINT, SIGTSTP, SIGWINCH, SIGHUP, SIGCHLD, SIGCONT,
     ];
@@ -24,4 +26,6 @@ fn main() -> Result<(), Error> {
         low_level::emulate_default_handler(signal)?;
     }
     Ok(())
+  }
+  #[cfg(not(feature = "iterator"))]Err(Error::new(ErrorKind::Unsupported,"this example requires the 'iterator' feature"))
 }
Index: signal-hook/tests/iterator.rs
===================================================================
--- signal-hook.orig/tests/iterator.rs
+++ signal-hook/tests/iterator.rs
@@ -10,7 +10,7 @@ use std::thread::{self, JoinHandle};
 use std::time::Duration;
 
 use signal_hook::consts::{SIGUSR1, SIGUSR2};
-use signal_hook::iterator::{Handle, Signals};
+#[cfg(feature = "iterator")]use signal_hook::iterator::{Handle, Signals};
 use signal_hook::low_level::raise;
 
 use serial_test::serial;
@@ -23,13 +23,13 @@ fn send_sigusr2() {
     raise(SIGUSR2).unwrap();
 }
 
-fn setup_without_any_signals() -> (Signals, Handle) {
+#[cfg(feature = "iterator")]fn setup_without_any_signals() -> (Signals, Handle) {
     let signals = Signals::new(&[]).unwrap();
     let controller = signals.handle();
     (signals, controller)
 }
 
-fn setup_for_sigusr2() -> (Signals, Handle) {
+#[cfg(feature = "iterator")]fn setup_for_sigusr2() -> (Signals, Handle) {
     let signals = Signals::new(&[SIGUSR2]).unwrap();
     let controller = signals.handle();
     (signals, controller)
@@ -49,7 +49,7 @@ macro_rules! assert_no_signals {
     };
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn forever_terminates_when_closed() {
     let (mut signals, controller) = setup_for_sigusr2();
@@ -79,7 +79,7 @@ fn forever_terminates_when_closed() {
 // tokio-support feature), blocking no longer works. The .wait() would return immediately (an empty
 // iterator, possibly), .forever() would do a busy loop.
 // flag)
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn signals_block_wait() {
     let mut signals = Signals::new(&[SIGUSR2]).unwrap();
@@ -144,7 +144,7 @@ fn signals_block_wait() {
     bg_thread.shutdown();
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn pending_doesnt_block() {
     let (mut signals, _) = setup_for_sigusr2();
@@ -154,7 +154,7 @@ fn pending_doesnt_block() {
     assert_no_signals!(recieved_signals);
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn wait_returns_recieved_signals() {
     let (mut signals, _) = setup_for_sigusr2();
@@ -165,7 +165,7 @@ fn wait_returns_recieved_signals() {
     assert_signals!(recieved_signals, SIGUSR2);
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn forever_returns_recieved_signals() {
     let (mut signals, _) = setup_for_sigusr2();
@@ -176,7 +176,7 @@ fn forever_returns_recieved_signals() {
     assert_signals!(signal, SIGUSR2);
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn wait_doesnt_block_when_closed() {
     let (mut signals, controller) = setup_for_sigusr2();
@@ -187,7 +187,7 @@ fn wait_doesnt_block_when_closed() {
     assert_no_signals!(recieved_signals);
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn wait_unblocks_when_closed() {
     let (mut signals, controller) = setup_without_any_signals();
@@ -201,7 +201,7 @@ fn wait_unblocks_when_closed() {
     thread.join().unwrap();
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn forever_doesnt_block_when_closed() {
     let (mut signals, controller) = setup_for_sigusr2();
@@ -212,7 +212,7 @@ fn forever_doesnt_block_when_closed() {
     assert_no_signals!(signal);
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn add_signal_after_creation() {
     let (mut signals, _) = setup_without_any_signals();
@@ -223,7 +223,7 @@ fn add_signal_after_creation() {
     assert_signals!(signals.pending(), SIGUSR1);
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn delayed_signal_consumed() {
     let (mut signals, _) = setup_for_sigusr2();
@@ -242,7 +242,7 @@ fn delayed_signal_consumed() {
     assert_no_signals!(recieved_signals);
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn is_closed_initially_returns_false() {
     let (_, controller) = setup_for_sigusr2();
@@ -250,7 +250,7 @@ fn is_closed_initially_returns_false() {
     assert!(!controller.is_closed());
 }
 
-#[test]
+#[cfg(feature = "iterator")]#[test]
 #[serial]
 fn is_closed_returns_true_when_closed() {
     let (_, controller) = setup_for_sigusr2();
Index: signal-hook/tests/shutdown.rs
===================================================================
--- signal-hook.orig/tests/shutdown.rs
+++ signal-hook/tests/shutdown.rs
@@ -70,7 +70,7 @@ fn cleanup_inside_signal() {
 
 /// Manually remove the signal handler just after receiving the signal but before going into an
 /// infinite loop.
-#[test]
+#[cfg(feature = "iterator")]#[test]
 fn cleanup_after_signal() {
     fn hook() {
         let mut signals = signal_hook::iterator::Signals::new(&[libc::SIGTERM]).unwrap();
