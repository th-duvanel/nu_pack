Index: rust-vm-memory-0.10.0/benches/mmap/mod.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/benches/mmap/mod.rs
+++ rust-vm-memory-0.10.0/benches/mmap/mod.rs
@@ -16,6 +16,9 @@ use criterion::{black_box, Criterion};
 
 use vm_memory::{ByteValued, Bytes, GuestAddress, GuestMemory};
 
+#[cfg(target_pointer_width = "32")]
+const REGION_SIZE: usize = 0x1000_0000;
+#[cfg(not(target_pointer_width = "32"))]
 const REGION_SIZE: usize = 0x8000_0000;
 const REGIONS_COUNT: u64 = 8;
 const ACCESS_SIZE: usize = 0x200;
Index: rust-vm-memory-0.10.0/src/bitmap/mod.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/src/bitmap/mod.rs
+++ rust-vm-memory-0.10.0/src/bitmap/mod.rs
@@ -235,7 +235,7 @@ pub(crate) mod tests {
         const BUF_SIZE: usize = 1024;
         let buf = vec![1u8; 1024];
 
-        let val = 1u64;
+        let val = 1usize;
 
         let h = BytesHelper {
             check_range_fn,
Index: rust-vm-memory-0.10.0/src/bytes.rs
===================================================================
--- rust-vm-memory-0.10.0.orig/src/bytes.rs
+++ rust-vm-memory-0.10.0/src/bytes.rs
@@ -380,8 +380,8 @@ pub(crate) mod tests {
             let end = begin + size_of::<T>();
             let unaligned_data = &mut data[begin..end];
             {
-                if align_of::<T>() != 1 {
-                    assert_eq!(T::from_slice(unaligned_data), None);
+                if (i % align_of::<T>()) != 0 {
+                    assert_eq!(T::from_slice(unaligned_data), None, "{}::from_slice(unaligned_data) with alignment offset {} was not none", std::any::type_name::<T>(),i);
                     assert_eq!(T::from_mut_slice(unaligned_data), None);
                 }
             }
