This patch is based on a revert of upstream commit ab5380a851490f866dad0e413868062a0258258c,
adapted for use in the Debian package by Peter Michael Green.

Index: ttrpc/build.rs
===================================================================
--- ttrpc.orig/build.rs
+++ ttrpc/build.rs
@@ -7,16 +7,10 @@ fn main() {
     let path: PathBuf = [out_dir.clone(), "mod.rs".to_string()].iter().collect();
     fs::write(path, "pub mod ttrpc;").unwrap();
 
-    let customize = protobuf_codegen::Customize::default()
-        .gen_mod_rs(false)
-        .generate_accessors(true);
-
-    protobuf_codegen::Codegen::new()
-        .pure()
+    protobuf_codegen_pure::Codegen::new()
         .out_dir(out_dir)
         .inputs(["src/ttrpc.proto"])
         .include("src")
-        .customize(customize)
         .run()
         .expect("Codegen failed.");
 }
Index: ttrpc/src/asynchronous/client.rs
===================================================================
--- ttrpc.orig/src/asynchronous/client.rs
+++ ttrpc/src/asynchronous/client.rs
@@ -70,7 +70,7 @@ impl Client {
 
         let msg: GenMessage = Message::new_request(stream_id, req)?
             .try_into()
-            .map_err(|e: protobuf::Error| Error::Others(e.to_string()))?;
+            .map_err(|e: protobuf::error::ProtobufError| Error::Others(e.to_string()))?;
 
         let (tx, mut rx): (ResultSender, ResultReceiver) = mpsc::channel(100);
 
@@ -101,8 +101,8 @@ impl Client {
         let res = Response::decode(msg.payload)
             .map_err(err_to_others_err!(e, "Unpack response error "))?;
 
-        let status = res.status();
-        if status.code() != Code::OK {
+        let status = res.get_status();
+        if status.get_code() != Code::OK {
             return Err(Error::RpcStatus((*status).clone()));
         }
 
@@ -121,7 +121,7 @@ impl Client {
 
         let mut msg: GenMessage = Message::new_request(stream_id, req)?
             .try_into()
-            .map_err(|e: protobuf::Error| Error::Others(e.to_string()))?;
+            .map_err(|e: protobuf::error::ProtobufError| Error::Others(e.to_string()))?;
 
         if streaming_client {
             if !is_req_payload_empty {
Index: ttrpc/src/asynchronous/stream.rs
===================================================================
--- ttrpc.orig/src/asynchronous/stream.rs
+++ ttrpc/src/asynchronous/stream.rs
@@ -458,7 +458,7 @@ impl StreamReceiver {
                 let resp = Response::decode(&msg.payload)
                     .map_err(err_to_others_err!(e, "Decode message failed."))?;
                 if let Some(status) = resp.status.as_ref() {
-                    if status.code() != Code::OK {
+                    if status.get_code() != Code::OK {
                         return Err(Error::RpcStatus((*status).clone()));
                     }
                 }
Index: ttrpc/src/asynchronous/utils.rs
===================================================================
--- ttrpc.orig/src/asynchronous/utils.rs
+++ ttrpc/src/asynchronous/utils.rs
@@ -145,15 +145,13 @@ macro_rules! async_duplex_streamimg_hand
 #[macro_export]
 macro_rules! async_client_request {
     ($self: ident, $ctx: ident, $req: ident, $server: expr, $method: expr, $cres: ident) => {
-        let mut creq = ttrpc::Request {
-            service: $server.to_string(),
-            method: $method.to_string(),
-            timeout_nano: $ctx.timeout_nano,
-            metadata: ttrpc::context::to_pb($ctx.metadata),
-            payload: Vec::with_capacity($req.compute_size() as usize),
-            ..Default::default()
-        };
-
+        let mut creq = ::ttrpc::Request::new();
+        creq.set_service($server.to_string());
+        creq.set_method($method.to_string());
+        creq.set_timeout_nano($ctx.timeout_nano);
+        let md = ::ttrpc::context::to_pb($ctx.metadata);
+        creq.set_metadata(md);
+        creq.payload.reserve($req.compute_size() as usize);
         {
             let mut s = CodedOutputStream::vec(&mut creq.payload);
             $req.write_to(&mut s)
Index: ttrpc/src/context.rs
===================================================================
--- ttrpc.orig/src/context.rs
+++ ttrpc/src/context.rs
@@ -48,7 +48,7 @@ impl Context {
     }
 }
 
-pub fn from_pb(kvs: &Vec<KeyValue>) -> HashMap<String, Vec<String>> {
+pub fn from_pb(kvs: &protobuf::RepeatedField<KeyValue>) -> HashMap<String, Vec<String>> {
     let mut meta: HashMap<String, Vec<String>> = HashMap::new();
     for kv in kvs {
         if let Some(ref mut vl) = meta.get_mut(&kv.key) {
@@ -60,9 +60,8 @@ pub fn from_pb(kvs: &Vec<KeyValue>) -> H
     meta
 }
 
-pub fn to_pb(kvs: HashMap<String, Vec<String>>) -> Vec<KeyValue> {
-    let mut meta = Vec::with_capacity(kvs.len());
-
+pub fn to_pb(kvs: HashMap<String, Vec<String>>) -> protobuf::RepeatedField<KeyValue> {
+    let mut meta: protobuf::RepeatedField<KeyValue> = protobuf::RepeatedField::default();
     for (k, vl) in kvs {
         for v in vl {
             let key = KeyValue {
@@ -73,7 +72,6 @@ pub fn to_pb(kvs: HashMap<String, Vec<St
             meta.push(key);
         }
     }
-
     meta
 }
 
@@ -85,7 +83,7 @@ mod tests {
     #[test]
     fn test_metadata() {
         // RepeatedField -> HashMap, test from_pb()
-        let mut src = Vec::new();
+        let mut src: protobuf::RepeatedField<KeyValue> = protobuf::RepeatedField::default();
         for i in &[
             ("key1", "value1-1"),
             ("key1", "value1-2"),
@@ -110,7 +108,8 @@ mod tests {
         assert_eq!(dst.get("key3"), None);
 
         // HashMap -> RepeatedField , test to_pb()
-        let mut kvs = context::to_pb(dst);
+        let src = context::to_pb(dst);
+        let mut kvs = src.into_vec();
         kvs.sort_by(|a, b| a.key.partial_cmp(&b.key).unwrap());
 
         assert_eq!(kvs.len(), 3);
Index: ttrpc/src/proto.rs
===================================================================
--- ttrpc.orig/src/proto.rs
+++ ttrpc/src/proto.rs
@@ -267,10 +267,10 @@ pub trait Codec {
 }
 
 impl<M: protobuf::Message> Codec for M {
-    type E = protobuf::Error;
+    type E = protobuf::error::ProtobufError;
 
     fn size(&self) -> u32 {
-        self.compute_size() as u32
+        self.compute_size()
     }
 
     fn encode(&self) -> Result<Vec<u8>, Self::E> {
@@ -278,7 +278,6 @@ impl<M: protobuf::Message> Codec for M {
         let mut s = CodedOutputStream::bytes(&mut buf);
         self.write_to(&mut s)?;
         s.flush()?;
-        drop(s);
         Ok(buf)
     }
 
@@ -433,11 +432,12 @@ mod tests {
         creq.set_service("grpc.TestServices".to_string());
         creq.set_method("Test".to_string());
         creq.set_timeout_nano(20 * 1000 * 1000);
-        let meta = vec![KeyValue {
+        let mut meta: protobuf::RepeatedField<KeyValue> = protobuf::RepeatedField::default();
+        meta.push(KeyValue {
             key: "test_key1".to_string(),
             value: "test_value1".to_string(),
             ..Default::default()
-        }];
+        });
         creq.set_metadata(meta);
         creq.payload = vec![0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9];
         creq
@@ -488,7 +488,7 @@ mod tests {
 
         match GenMessage::read_from(&*buf).await {
             Err(GenMessageError::ReturnError(h, Error::RpcStatus(s))) => {
-                if h != header || s.code() != crate::proto::Code::INVALID_ARGUMENT {
+                if h != header || s.code != crate::proto::Code::INVALID_ARGUMENT {
                     panic!("got invalid error when the size exceeds limit");
                 }
             }
Index: ttrpc/src/sync/client.rs
===================================================================
--- ttrpc.orig/src/sync/client.rs
+++ ttrpc/src/sync/client.rs
@@ -180,8 +180,8 @@ impl Client {
         let buf = result?;
         let res = Response::decode(buf).map_err(err_to_others_err!(e, "Unpack response error "))?;
 
-        let status = res.status();
-        if status.code() != Code::OK {
+        let status = res.get_status();
+        if status.get_code() != Code::OK {
             return Err(Error::RpcStatus((*status).clone()));
         }
 
Index: ttrpc/src/sync/utils.rs
===================================================================
--- ttrpc.orig/src/sync/utils.rs
+++ ttrpc/src/sync/utils.rs
@@ -94,8 +94,6 @@ macro_rules! client_request {
             .map_err(::ttrpc::err_to_others!(e, ""))?;
         s.flush().map_err(::ttrpc::err_to_others!(e, ""))?;
 
-        drop(s);
-
         let res = $self.client.request(creq)?;
         let mut s = CodedInputStream::from_bytes(&res.payload);
         $cres
Index: ttrpc/Cargo.toml
===================================================================
--- ttrpc.orig/Cargo.toml
+++ ttrpc/Cargo.toml
@@ -61,3 +61,3 @@
 [dependencies.protobuf]
-version = "3.1.0"
+version = "2.14"
 
@@ -81,2 +81,2 @@ optional = true
-[build-dependencies.protobuf-codegen]
-version = "3.1.0"
+[build-dependencies.protobuf-codegen-pure]
+version = "2.14"
