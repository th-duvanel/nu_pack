--- a/Cargo.toml
+++ b/Cargo.toml
@@ -41,5 +41,5 @@
 [dependencies.syn]
 version = "2.0"
 features = ["parsing", "extra-traits"]
-[dev-dependencies.strum]
-version = "0.26"
+#[dev-dependencies.strum]
+#version = "0.26"
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -51,7 +51,7 @@
 /// perfect hash functions to parse much quicker than a standard `match`. (MSRV 1.46)
 ///
 /// # Example howto use `EnumString`
-/// ```
+/// ```ignore (Debian: avoid circular dependency, cargo test -- --ignored to still run)
 /// use std::str::FromStr;
 /// use strum_macros::EnumString;
 ///
@@ -168,7 +168,7 @@
 /// Adds an `impl` block for the `enum` that adds a static `VARIANTS` array of `&'static str` that are the discriminant names.
 /// This will respect the `serialize_all` attribute on the `enum` (like `#[strum(serialize_all = "snake_case")]`.
 ///
-/// ```
+/// ```ignore (Debian: avoid circular dependency, cargo test -- --ignored to still run)
 /// // import the macros needed
 /// use strum_macros::{EnumString};
 /// // You need to import the trait, to have access to VARIANTS
@@ -217,7 +217,7 @@
 /// This trait can only be autoderived if the enumerator is composed only of unit-type variants,
 /// meaning that the variants must not have any data.
 ///
-/// ```
+/// ```ignore (Debian: avoid circular dependency, cargo test -- --ignored to still run)
 /// use strum::VariantArray;
 ///
 /// #[derive(VariantArray, Debug, PartialEq, Eq)]
@@ -415,7 +415,7 @@
 /// You cannot derive `EnumIter` on any type with a lifetime bound (`<'a>`) because the iterator would surely
 /// create [unbounded lifetimes](https://doc.rust-lang.org/nightly/nomicon/unbounded-lifetimes.html).
 ///
-/// ```
+/// ```ignore (Debian: avoid circular dependency, cargo test -- --ignored to still run)
 ///
 /// // You need to bring the trait into scope to use it!
 /// use strum::IntoEnumIterator;
@@ -658,7 +658,7 @@
 /// but `get_message` should generally be preferred. Rust doc comments are intended for developer facing documentation,
 /// not end user messaging.
 ///
-/// ```
+/// ```ignore (Debian: avoid circular dependency, cargo test -- --ignored to still run)
 /// // You need to bring the trait into scope to use it
 /// use strum::EnumMessage;
 /// use strum_macros;
@@ -746,7 +746,7 @@
 /// number of variants and properties, but scales linearly with the number of variants so may not
 /// be the best choice in all situations.
 ///
-/// ```
+/// ```ignore (Debian: avoid circular dependency, cargo test -- --ignored to still run)
 ///
 /// use strum_macros;
 /// // bring the trait into scope
@@ -805,7 +805,7 @@
 /// are passed through by default. If you want to specify a custom attribute on the discriminant
 /// variant, wrap it with `#[strum_discriminants(...)]` attribute.
 ///
-/// ```
+/// ```ignore (Debian: avoid circular dependency, cargo test -- --ignored to still run)
 /// // Bring trait into scope
 /// use std::str::FromStr;
 /// use strum::{IntoEnumIterator, EnumMessage};
@@ -905,7 +905,7 @@
 /// For a given enum generates implementation of `strum::EnumCount`,
 /// which adds a static property `COUNT` of type usize that holds the number of variants.
 ///
-/// ```
+/// ```ignore (Debian: avoid circular dependency, cargo test -- --ignored to still run)
 /// use strum::{EnumCount, IntoEnumIterator};
 /// use strum_macros::{EnumCount as EnumCountMacro, EnumIter};
 ///
