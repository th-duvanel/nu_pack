diff --git a/src/lib.rs b/src/lib.rs
index 5c4f200..73f5ddb 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -29,37 +29,6 @@
 //! workaround using `waitpid` for these platforms as we run into them. Please
 //! [file an issue](https://github.com/oconnor663/shared_child.rs/issues/new) if
 //! you hit this.
-//!
-//! # Example
-//!
-//! ```rust
-//! use shared_child::SharedChild;
-//! use std::process::Command;
-//! use std::sync::Arc;
-//!
-//! // Spawn a child that will just sleep for a long time,
-//! // and put it in an Arc to share between threads.
-//! let mut command = Command::new("python");
-//! command.arg("-c").arg("import time; time.sleep(1000000000)");
-//! let shared_child = SharedChild::spawn(&mut command).unwrap();
-//! let child_arc = Arc::new(shared_child);
-//!
-//! // On another thread, wait on the child process.
-//! let child_arc_clone = child_arc.clone();
-//! let thread = std::thread::spawn(move || {
-//!     child_arc_clone.wait().unwrap()
-//! });
-//!
-//! // While the other thread is waiting, kill the child process.
-//! // This wouldn't be possible with e.g. Arc<Mutex<Child>> from
-//! // the standard library, because the waiting thread would be
-//! // holding the mutex.
-//! child_arc.kill().unwrap();
-//!
-//! // Join the waiting thread and get the exit status.
-//! let exit_status = thread.join().unwrap();
-//! assert!(!exit_status.success());
-//! ```
 
 use std::io;
 use std::process::{Child, ChildStderr, ChildStdin, ChildStdout, Command, ExitStatus};
