diff --git a/Cargo.toml b/Cargo.toml
index d77d87e..d9471e3 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -40,7 +40,7 @@ version = ">=0.2.0,<0.4"
 optional = true
 
 [dependencies.hash32]
-version = "0.2.1"
+version = "0.3"
 
 [dependencies.serde]
 version = "1"
diff --git a/src/indexmap.rs b/src/indexmap.rs
index f3dfc3c..514a0f7 100644
--- a/src/indexmap.rs
+++ b/src/indexmap.rs
@@ -1,6 +1,10 @@
 use core::{borrow::Borrow, fmt, iter::FromIterator, mem, num::NonZeroU32, ops, slice};
+use core::hash::Hash;
+use core::hash::Hasher;
 
-use hash32::{BuildHasher, BuildHasherDefault, FnvHasher, Hash, Hasher};
+use core::hash::BuildHasher;
+
+use hash32::{BuildHasherDefault, FnvHasher};
 
 use crate::Vec;
 
diff --git a/src/indexset.rs b/src/indexset.rs
index b2c97fb..5669156 100644
--- a/src/indexset.rs
+++ b/src/indexset.rs
@@ -1,6 +1,8 @@
 use crate::indexmap::{self, IndexMap};
 use core::{borrow::Borrow, fmt, iter::FromIterator};
-use hash32::{BuildHasher, BuildHasherDefault, FnvHasher, Hash};
+use hash32::{BuildHasherDefault, FnvHasher};
+use core::hash::Hash;
+use core::hash::BuildHasher;
 
 /// A [`heapless::IndexSet`](./struct.IndexSet.html) using the
 /// default FNV hasher.
diff --git a/src/spsc.rs b/src/spsc.rs
index 3d00a44..e29e8b0 100644
--- a/src/spsc.rs
+++ b/src/spsc.rs
@@ -451,18 +451,6 @@ where
     }
 }
 
-impl<T, const N: usize> hash32::Hash for Queue<T, N>
-where
-    T: hash32::Hash,
-{
-    fn hash<H: hash32::Hasher>(&self, state: &mut H) {
-        // iterate over self in order
-        for t in self.iter() {
-            hash32::Hash::hash(t, state);
-        }
-    }
-}
-
 impl<'a, T, const N: usize> IntoIterator for &'a Queue<T, N> {
     type Item = &'a T;
     type IntoIter = Iter<'a, T, N>;
@@ -591,7 +579,6 @@ impl<'a, T, const N: usize> Producer<'a, T, N> {
 #[cfg(test)]
 mod tests {
     use crate::spsc::Queue;
-    use hash32::Hasher;
 
     #[test]
     fn full() {
@@ -874,6 +861,8 @@ mod tests {
 
     #[test]
     fn hash_equality() {
+        use std::hash::Hasher;
+
         // generate two queues with same content
         // but different buffer alignment
         let rb1 = {
@@ -892,13 +881,13 @@ mod tests {
         };
         let hash1 = {
             let mut hasher1 = hash32::FnvHasher::default();
-            hash32::Hash::hash(&rb1, &mut hasher1);
+            core::hash::Hash::hash(&rb1, &mut hasher1);
             let hash1 = hasher1.finish();
             hash1
         };
         let hash2 = {
             let mut hasher2 = hash32::FnvHasher::default();
-            hash32::Hash::hash(&rb2, &mut hasher2);
+            core::hash::Hash::hash(&rb2, &mut hasher2);
             let hash2 = hasher2.finish();
             hash2
         };
diff --git a/src/string.rs b/src/string.rs
index 6611eb7..649597e 100644
--- a/src/string.rs
+++ b/src/string.rs
@@ -1,7 +1,5 @@
 use core::{cmp::Ordering, fmt, fmt::Write, hash, iter, ops, str};
 
-use hash32;
-
 use crate::Vec;
 
 /// A fixed capacity [`String`](https://doc.rust-lang.org/std/string/struct.String.html)
@@ -364,13 +362,6 @@ impl<const N: usize> hash::Hash for String<N> {
     }
 }
 
-impl<const N: usize> hash32::Hash for String<N> {
-    #[inline]
-    fn hash<H: hash32::Hasher>(&self, hasher: &mut H) {
-        <str as hash32::Hash>::hash(self, hasher)
-    }
-}
-
 impl<const N: usize> fmt::Write for String<N> {
     fn write_str(&mut self, s: &str) -> Result<(), fmt::Error> {
         self.push_str(s).map_err(|_| fmt::Error)
diff --git a/src/vec.rs b/src/vec.rs
index 33a29e0..a77ba52 100644
--- a/src/vec.rs
+++ b/src/vec.rs
@@ -2,7 +2,6 @@ use core::{
     cmp::Ordering, convert::TryFrom, fmt, hash, iter::FromIterator, mem::MaybeUninit, ops, ptr,
     slice,
 };
-use hash32;
 
 /// A fixed capacity [`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html)
 ///
@@ -898,15 +897,6 @@ where
     }
 }
 
-impl<T, const N: usize> hash32::Hash for Vec<T, N>
-where
-    T: hash32::Hash,
-{
-    fn hash<H: hash32::Hasher>(&self, state: &mut H) {
-        <[T] as hash32::Hash>::hash(self, state)
-    }
-}
-
 impl<'a, T, const N: usize> IntoIterator for &'a Vec<T, N> {
     type Item = &'a T;
     type IntoIter = slice::Iter<'a, T>;
