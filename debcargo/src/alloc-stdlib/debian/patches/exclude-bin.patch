diff --git a/Cargo.toml b/Cargo.toml
index 814e980..4256b4c 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -13,7 +13,6 @@
 name = "alloc-stdlib"
 version = "0.2.2"
 authors = ["Daniel Reiter Horn <danielrh@dropbox.com>"]
-autobins = false
 description = "A dynamic allocator example that may be used with the stdlib"
 homepage = "https://github.com/dropbox/rust-alloc-no-stdlib"
 documentation = "https://raw.githubusercontent.com/dropbox/rust-alloc-no-stdlib/master/alloc-stdlib/tests/lib.rs"
@@ -28,9 +27,6 @@ keywords = [
 license = "BSD-3-Clause"
 repository = "https://github.com/dropbox/rust-alloc-no-stdlib"
 
-[[bin]]
-name = "example"
-
 [dependencies.alloc-no-stdlib]
 version = "2.0.4"
 
diff --git a/src/bin/example.rs b/src/bin/example.rs
deleted file mode 100644
index 6b16101..0000000
--- a/src/bin/example.rs
+++ /dev/null
@@ -1,122 +0,0 @@
-//#![feature(trace_macros)]
-extern crate alloc_stdlib;
-#[macro_use]
-extern crate alloc_no_stdlib;
-
-extern crate core;
-use core::ops;
-
-pub use alloc_stdlib::{HeapAlloc, StandardAlloc};
-use alloc_stdlib::HeapPrealloc;
-mod tests;
-extern {
-  fn calloc(n_elem : usize, el_size : usize) -> *mut u8;
-}
-extern {
-  fn free(ptr : *mut u8);
-}
-
-
-//use alloc::AllocatedSlice;
-use alloc_no_stdlib::SliceWrapper;
-use alloc_no_stdlib::SliceWrapperMut;
-use alloc_no_stdlib::AllocatedStackMemory;
-use alloc_no_stdlib::Allocator;
-use alloc_no_stdlib::StackAllocator;
-
-use alloc_no_stdlib::bzero;
-declare_stack_allocator_struct!(CallocAllocatedFreelist4, 4, calloc);
-declare_stack_allocator_struct!(StackAllocatedFreelist16, 16, stack);
-
-fn show_heap_prealloc() {
-  let mut zero_global_buffer = define_allocator_memory_pool!(4, u8, [0; 1024 * 1024 * 20], heap);
-
-  let mut boxallocator = HeapPrealloc::<u8>::new_allocator(1024 * 1024, &mut zero_global_buffer, bzero);
-
-  {
-    let mut x = boxallocator.alloc_cell(9999);
-    x.slice_mut()[0] = 3;
-    let mut y = boxallocator.alloc_cell(4);
-    y[0] = 5;
-    boxallocator.free_cell(y);
-
-    let mut three = boxallocator.alloc_cell(3);
-    three[0] = 6;
-    boxallocator.free_cell(three);
-
-    let mut z = boxallocator.alloc_cell(4);
-    z.slice_mut()[1] = 8;
-    let mut reget_three = boxallocator.alloc_cell(4);
-    reget_three.slice_mut()[1] = 9;
-    //y.mem[0] = 6; // <-- this is an error (use after free)
-    println!("x[0] = {:?} z[0] = {:?}  z[1] = {:?} r3[0] = {:?} r3[1] = {:?}", x.mem[0], z.mem[0], z.mem[1], reget_three[0], reget_three.slice()[1]);
-    let mut _z = boxallocator.alloc_cell(1);
-  }
-}
-
-fn main() {
-  let mut global_buffer = unsafe {define_allocator_memory_pool!(4, u8, [0; 1024 * 1024 * 200], calloc)};
-  {
-  let gbref = &mut global_buffer;
-{
-  let mut ags = CallocAllocatedFreelist4::<u8>::new_allocator(gbref.data, bzero);
-
-  {
-  let mut x = ags.alloc_cell(9999);
-  x.slice_mut()[0] = 4;
-  let mut y = ags.alloc_cell(4);
-  y[0] = 5;
-  ags.free_cell(y);
-
-  let mut three = ags.alloc_cell(3);
-  three[0] = 6;
-  ags.free_cell(three);
-
-  let mut z = ags.alloc_cell(4);
-  z.slice_mut()[1] = 8;
-  let mut reget_three = ags.alloc_cell(4);
-  reget_three.slice_mut()[1] = 9;
-  //y.mem[0] = 6; // <-- this is an error (use after free)
-  println!("x[0] = {:?} z[0] = {:?}  z[1] = {:?} r3[0] = {:?} r3[1] = {:?}", x.mem[0], z.mem[0], z.mem[1], reget_three[0], reget_three.slice()[1]);
-  let mut _z = ags.alloc_cell(1);
-  }
-  }
-  }
-
-
-  let mut stack_global_buffer = define_allocator_memory_pool!(16, u8, [0; 1024 * 1024], stack);
-  let mut stackallocator = StackAllocatedFreelist16::<u8>::new_allocator(&mut stack_global_buffer, bzero);
-  {
-    let mut x = stackallocator.alloc_cell(9999);
-    x.slice_mut()[0] = 3;
-    let mut y = stackallocator.alloc_cell(4);
-    y[0] = 5;
-    stackallocator.free_cell(y);
-
-    let mut three = stackallocator.alloc_cell(3);
-    three[0] = 6;
-    stackallocator.free_cell(three);
-
-    let mut z = stackallocator.alloc_cell(4);
-    z.slice_mut()[1] = 8;
-    let mut reget_three = stackallocator.alloc_cell(4);
-    reget_three.slice_mut()[1] = 9;
-    //y.mem[0] = 6; // <-- this is an error (use after free)
-    println!("x[0] = {:?} z[0] = {:?}  z[1] = {:?} r3[0] = {:?} r3[1] = {:?}", x.mem[0], z.mem[0], z.mem[1], reget_three[0], reget_three.slice()[1]);
-    let mut _z = stackallocator.alloc_cell(1);
-  }
-
-  let mut halloc = HeapAlloc::<u8>::default();
-  for _i in 1..10 { // heap test
-      let mut x = halloc.alloc_cell(100000);
-      x.slice_mut()[0] = 4;
-      let mut y = halloc.alloc_cell(110000);
-      y.slice_mut()[0] = 5;
-      let mut z = halloc.alloc_cell(120000);
-      z.slice_mut()[0] = 6;
-      halloc.free_cell(y);
-      println!("x[0] {:?} x[9] {:?} y[0] {:?} z[0] {:?}",
-               x.slice()[0], x.slice()[9], -999, z.slice()[0]);
-  }
-  show_heap_prealloc();
-}
diff --git a/src/bin/tests.rs b/src/bin/tests.rs
deleted file mode 100755
index 4afc46a..0000000
--- a/src/bin/tests.rs
+++ /dev/null
@@ -1,85 +0,0 @@
-#![allow(unused_imports)]
-#[cfg(test)]
-extern crate core;
-use alloc_no_stdlib::{Allocator, SliceWrapper, SliceWrapperMut};
-use super::{HeapAlloc, StandardAlloc};
-#[cfg(feature="unsafe")]
-use alloc_stdlib::HeapAllocUninitialized;
-#[test]
-fn heap_test() {
-  let mut halloc : HeapAlloc<u8> = HeapAlloc::<u8>{default_value: 0};
-  for _i in 1..10 { // heap test
-      let mut x = halloc.alloc_cell(100000);
-      x.slice_mut()[0] = 4;
-      let mut y = halloc.alloc_cell(110000);
-      y.slice_mut()[0] = 5;
-      let mut z = halloc.alloc_cell(120000);
-      z.slice_mut()[0] = 6;
-      assert_eq!(y.slice()[0], 5);
-      halloc.free_cell(y);
-      assert_eq!(x.slice()[0], 4);
-      assert_eq!(x.slice()[9], 0);
-      assert_eq!(z.slice()[0], 6);
-  }
-
-}
-
-#[test]
-fn std_test() {
-  let mut halloc = StandardAlloc::default();
-  for _i in 1..10 { // heap test
-      let mut x = <StandardAlloc as Allocator<u8>>::alloc_cell(&mut halloc, 100000);
-      x.slice_mut()[0] = 4;
-      let mut y = <StandardAlloc as Allocator<u8>>::alloc_cell(&mut halloc, 110000);
-      y.slice_mut()[0] = 5;
-      let mut z = <StandardAlloc as Allocator<u8>>::alloc_cell(&mut halloc, 120000);
-      z.slice_mut()[0] = 6;
-      assert_eq!(y.slice()[0], 5);
-      halloc.free_cell(y);
-      assert_eq!(x.slice()[0], 4);
-      assert_eq!(x.slice()[9], 0);
-      assert_eq!(z.slice()[0], 6);
-  }
-
-}
-
-
-#[cfg(feature="unsafe")]
-#[test]
-fn std_unsafe_heap_test() {
-  let mut halloc = unsafe{HeapAllocUninitialized::<u8>::new()};
-  for _i in 1..10 { // heap test
-      let mut x = halloc.alloc_cell(100000);
-      x.slice_mut()[0] = 4;
-      let mut y = halloc.alloc_cell(110000);
-      y.slice_mut()[0] = 5;
-      let mut z = halloc.alloc_cell(120000);
-      z.slice_mut()[0] = 6;
-      assert_eq!(y.slice()[0], 5);
-      halloc.free_cell(y);
-      assert_eq!(x.slice()[0], 4);
-      assert_eq!(x.slice()[9], 0);
-      assert_eq!(z.slice()[0], 6);
-  }
-
-}
-
-#[cfg(feature="stdlib")]
-#[test]
-fn std_heap_test() {
-  let mut halloc = HeapAlloc::<u8>::new(0);
-  for _i in 1..10 { // heap test
-      let mut x = halloc.alloc_cell(100000);
-      x.slice_mut()[0] = 4;
-      let mut y = halloc.alloc_cell(110000);
-      y.slice_mut()[0] = 5;
-      let mut z = halloc.alloc_cell(120000);
-      z.slice_mut()[0] = 6;
-      assert_eq!(y.slice()[0], 5);
-      halloc.free_cell(y);
-      assert_eq!(x.slice()[0], 4);
-      assert_eq!(x.slice()[9], 0);
-      assert_eq!(z.slice()[0], 6);
-  }
-
-}
