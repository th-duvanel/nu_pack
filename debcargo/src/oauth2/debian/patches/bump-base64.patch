Index: oauth2/Cargo.toml
===================================================================
--- oauth2.orig/Cargo.toml
+++ oauth2/Cargo.toml
@@ -27,7 +27,7 @@ repository = "https://github.com/ramosbu
 all-features = true
 
 [dependencies.base64]
-version = "0.13"
+version = "0.21"
 
 [dependencies.chrono]
 version = "0.4"
Index: oauth2/src/lib.rs
===================================================================
--- oauth2.orig/src/lib.rs
+++ oauth2/src/lib.rs
@@ -429,6 +429,8 @@ use std::time::Duration;
 
 use chrono::serde::ts_seconds_option;
 use chrono::{DateTime, Utc};
+use base64::engine::general_purpose::STANDARD;
+use base64::engine::Engine as _;
 use http::header::{HeaderMap, HeaderValue, ACCEPT, AUTHORIZATION, CONTENT_TYPE};
 use http::status::StatusCode;
 use serde::de::DeserializeOwned;
@@ -1998,7 +2000,7 @@ fn endpoint_request<'a>(
             let urlencoded_secret: String =
                 form_urlencoded::byte_serialize(secret.secret().as_bytes()).collect();
             let b64_credential =
-                base64::encode(&format!("{}:{}", &urlencoded_id, urlencoded_secret));
+                STANDARD.encode(&format!("{}:{}", &urlencoded_id, urlencoded_secret));
             headers.append(
                 AUTHORIZATION,
                 HeaderValue::from_str(&format!("Basic {}", &b64_credential)).unwrap(),
Index: oauth2/src/types.rs
===================================================================
--- oauth2.orig/src/types.rs
+++ oauth2/src/types.rs
@@ -3,6 +3,8 @@ use std::fmt::Error as FormatterError;
 use std::fmt::{Debug, Formatter};
 use std::ops::Deref;
 
+use base64::engine::general_purpose::URL_SAFE_NO_PAD;
+use base64::engine::Engine as _;
 use rand::{thread_rng, Rng};
 use serde::{Deserialize, Serialize};
 use sha2::{Digest, Sha256};
@@ -481,10 +483,7 @@ impl PkceCodeChallenge {
         // This implies 32-96 octets of random data to be base64 encoded.
         assert!(num_bytes >= 32 && num_bytes <= 96);
         let random_bytes: Vec<u8> = (0..num_bytes).map(|_| thread_rng().gen::<u8>()).collect();
-        PkceCodeVerifier::new(base64::encode_config(
-            &random_bytes,
-            base64::URL_SAFE_NO_PAD,
-        ))
+        PkceCodeVerifier::new(URL_SAFE_NO_PAD.encode(&random_bytes))
     }
 
     ///
@@ -501,7 +500,7 @@ impl PkceCodeChallenge {
         assert!(code_verifier.secret().len() >= 43 && code_verifier.secret().len() <= 128);
 
         let digest = Sha256::digest(code_verifier.secret().as_bytes());
-        let code_challenge = base64::encode_config(&digest, base64::URL_SAFE_NO_PAD);
+        let code_challenge = URL_SAFE_NO_PAD.encode(&digest);
 
         Self {
             code_challenge,
@@ -597,7 +596,7 @@ new_secret_type![
         ///
         pub fn new_random_len(num_bytes: u32) -> Self {
             let random_bytes: Vec<u8> = (0..num_bytes).map(|_| thread_rng().gen::<u8>()).collect();
-            CsrfToken::new(base64::encode_config(&random_bytes, base64::URL_SAFE_NO_PAD))
+            CsrfToken::new(URL_SAFE_NO_PAD.encode(&random_bytes))
         }
     }
 ];
